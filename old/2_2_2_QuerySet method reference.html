<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Language" content="en-us" />

		<title>Django | 查询API参考 (QuerySet API reference) | Django文档 (Django Documentation)</title>

		<meta name="ROBOTS" content="ALL" />
		<meta http-equiv="imagetoolbar" content="no" />
		<meta name="MSSmartTagsPreventParsing" content="true" />
		<meta name="Copyright" content="This site's design and contents Copyright (c) 2005  Lawrence Journal-World." />

		<meta name="keywords" content="Python, Django, framework, open-source" />
		<meta name="description" content="Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design." />

		<link href="http://media.djangoproject.com/css/base.css" rel="stylesheet" type="text/css" media="screen" />
		<link href="http://media.djangoproject.com/css/print.css" rel="stylesheet" type="text/css" media="print" />
      
  
  <style type="text/css" media="screen">
    #docs-search {
      color: #000;
      float: right;
    }
    #docs-search form {
      font-size: 92%;
      margin: 0;
      padding: 1em 1em 0;
      white-space: nowrap;
    }
    form.search ul {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    form.search li {
      display: inline;
      padding-right: 1em;
    }
    form.search .query {
      width: 18em;
    }
  </style>
  <link rel="stylesheet" href="http://media.djangoproject.com/css/pygments.css" type="text/css" />

	</head>

	<body id="documentation" class="default">

	<div id="container">
		<div id="header">
			<h1 id="logo"><a href="http://www.djangoproject.com/"><img src="http://media.djangoproject.com/img/site/hdr_logo.gif" alt="Django" /></a></h1>
			<ul id="nav-global">
				<li id="nav-homepage"><a href="http://www.djangoproject.com/">Home</a></li>
				<li id="nav-download"><a href="http://www.djangoproject.com/download/">Download</a></li>
				<li id="nav-documentation"><a href="http://docs.djangoproject.com/">Documentation</a></li>
				<li id="nav-weblog"><a href="http://www.djangoproject.com/weblog/">Weblog</a></li>
				<li id="nav-community"><a href="http://www.djangoproject.com/community/">Community</a></li>
				<li id="nav-code"><a href="http://code.djangoproject.com/">Code</a></li>
			</ul>
		</div>
		<!-- END Header -->
		<div id="billboard">
  <h2><a href="../../../index.html">Django 文档</a></h2>
</div>
		<div id="columnwrap">
			
		<div id="content-main">
		


  <h2 class="deck">
  
    当前文档仅适用于 Django SVN 版本，与上个版本有显著不同。上个版本文档请查阅：      <a href="http://docs.djangoproject.com/en/1.0/ref/models/querysets/">Django 1.0</a>
  
  </h2>
  <div class="section" id="s-queryset-api-reference">
<span id="s-ref-models-querysets"></span><span id="queryset-api-reference"></span><span id="ref-models-querysets"></span><h1>查询集 API 参考(QuerySet API reference)<a class="headerlink" href="index.html#queryset-api-reference" title="Permalink to this headline">¶</a></h1>
<p>该文档详细介绍了 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的 API。这里面的内容是建立在 <a class="reference external" href="../../../topics/db/models/index.html#topics-db-models"><em>model</em></a> 和 <a class="reference external" href="../../../topics/db/queries/index.html#topics-db-queries"><em>database query</em></a> 文档的基础上，所以建议您在看该文档之前先读一下这两个文档。</p>
<p>贯穿该文档，我们仍使用<a class="reference external" href="../../../topics/db/queries/index.html#topics-db-queries"><em>database query guide</em></a> 文档中的 <a class="reference external" href="../../../topics/db/queries/index.html#queryset-model-example"><em>example weblog models</em></a> 为例：</p>
<div class="section" id="s-id1">
<span id="s-when-querysets-are-evaluated"></span><span id="id1"></span><span id="when-querysets-are-evaluated"></span><h2>在查询时发生了什么(When QuerySets are evaluated)<a class="headerlink" href="index.html#id1" title="Permalink to this headline">¶</a></h2>
<p>从内部讲，<tt class="docutils literal"><span class="pre">QuerySet</span></tt> 可以被构造，过滤，切片，做为参数传递，这些行为都不会对数据库进行操作。只要你查询的时候才真正的操作数据库。</p>
<p>下面的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 行为会导致执行查询的操作：</p>
<ul>
<li><p class="first"><strong>循环(Iteration)</strong>：<tt class="docutils literal"><span class="pre">QuerySet</span></tt> 是可迭代的，在你遍历对象时就会执行数据库操作。例如，打印出所有博文的大标题：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">e</span><span class="o">.</span><span class="n">headline</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>切片(Slicing)</strong>：在 <a class="reference external" href="../../../topics/db/queries/index.html#limiting-querysets"><em>查询限定(Limiting QuerySets)</em></a> 中提到, a <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 是可以用 Python 的数组切片语法完成切片。一般来说对一个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 切片就返回另一个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> (新 QuerySet 不会被执行)。不过如果你在切片时使用了 <b>&quot;step&quot;</b> 参数，Django 仍会执行数据库操作。</p>
</li>
<li><p class="first"><strong>序列化／缓存化(Pickling/Caching)：</strong> 详情请查看 <a class="reference internal" href="index.html#pickling-querysets">pickling QuerySets</a>。 这一节所强调的一点是查询结果是从数据库中读取的。</p>
</li>
<li><p class="first"><strong>repr().</strong> 调用 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的 <tt class="docutils literal"><span class="pre">repr()</span></tt> 方法时，查询就会被运行。这对于 Python 命令行来说非常方便，你可以使用 API 立即看到查询结果。</p>
</li>
<li><p class="first"><strong>len().</strong> 调用 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的 <tt class="docutils literal"><span class="pre">len()</span></tt> 方法，查询就会被运行。这正如你所料，会返回查询结果列表的长度。</p>
<p>注意：如果你想得到集合中记录的数量，就<b>不要</b>使用 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的 <tt class="docutils literal"><span class="pre">len()</span></tt> 方法。因为直接在数据库层面使用 SQL 的 <tt class="docutils literal"><span class="pre">SELECT</span> <span class="pre">COUNT(*)</span></tt> 会更加高效，Django 提供了 <tt class="docutils literal"><span class="pre">count()</span></tt> 方法就是这个原因。详情参阅下面的 <tt class="docutils literal"><span class="pre">count()</span></tt> 方法。</p>
</li>
<li><p class="first"><strong>list().</strong> 对 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 应用 <tt class="docutils literal"><span class="pre">list()</span></tt> 方法，就会运行查询。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">entry_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
</pre></div>
</div>
<p>要注意地是：使用这个方法会占用大量内存，因为 Django 将列表内容都载入到内存中。做为对比，遍历 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 是从数据库读取数据，仅在使用某个对象时才将其载入到内容中。</p>
</li>
</ul>
<div class="section" id="s-id2">
<span id="s-pickling-querysets"></span><span id="id2"></span><span id="pickling-querysets"></span><h3>Pickling QuerySets<a class="headerlink" href="index.html#id2" title="Permalink to this headline">¶</a></h3>
<p>如果你要 <a class="reference external" href="http://docs.python.org/lib/module-pickle.html">序列化(pickle)</a> 一个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>，Django 首先就会将查询对象载入到内存中以完成序列化，这样你就可以第一时间使用对象(直接从数据库中读取数据需要一定时间，这正是缓存所想避免的)。而序列化是缓存化的先行工作，所以在缓存查询时，首先就会进行序列化工作。这意味着当你反序列化 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 时，第一时间就会从内存中获得查询的结果，而不是从数据库中查找。</p>
<p>如果你只是想序列化部分必要的信息以便晚些时候可以从数据库中重建 <tt class="docutils literal"><span class="pre">Queryset</span></tt> ，那只序列化 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的 <tt class="docutils literal"><span class="pre">query</span></tt> 属性即可。接下来你就可以使用下面的代码重建原来的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> （这当中没有数据库读取）：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">query</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>     <span class="c"># Assuming &#39;s&#39; is the pickled string.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qs</span> <span class="o">=</span> <span class="n">MyModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qs</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">query</span>            <span class="c"># Restore the original &#39;query&#39;.</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">query</span></tt> 属性是一个不透明的对象。这就意味着它的内部结构并不是公开的。即便如此，对于本节提到的序列化和反序列化来说，它仍是安全和被完全支持的。</p>
</div>
</div>
<div class="section" id="s-id3">
<span id="s-queryset-api"></span><span id="id3"></span><span id="queryset-api"></span><h2>查询API(QuerySet API)<a class="headerlink" href="index.html#id3" title="Permalink to this headline">¶</a></h2>
<p>一般情况下，我们都是直接使用而不是手动创建一个 <a title="django.db.models.Manager" class="reference external" href="../../../topics/db/managers/index.html#django.db.models.Manager"><tt class="xref docutils literal"><span class="pre">Manager</span></tt></a> ，但在这里我们仍要介绍一下 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的形式。</p>
<dl class="class">
<dt id="django.db.models.QuerySet">
<!--[django.db.models.QuerySet]-->class <tt class="descname">QuerySet</tt>(<span class="optional">[</span><em>model=None</em><span class="optional">]</span>)<a class="headerlink" href="index.html#django.db.models.QuerySet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>通常你想修改某个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 时，你会使用 <a class="reference external" href="../../../topics/db/queries/index.html#chaining-filters"><em>过滤链(chaining filters)</em></a>。所以为了让它们能正常工作，大多数 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 方法都返回<b>新的</b>查询(querysets)。</p>
<div class="section" id="s-queryset-methods-that-return-new-querysets">
<span id="queryset-methods-that-return-new-querysets"></span><h3>返回新查询的方法(QuerySet methods that return new QuerySets)<a class="headerlink" href="index.html#queryset-methods-that-return-new-querysets" title="Permalink to this headline">¶</a></h3>
<p>Django 为 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 提供了一套优雅的方法，用来修改 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 查询结果的类型和运行 SQL 查询的方式。</p>
<div class="section" id="s-filter-kwargs">
<span id="filter-kwargs"></span><h4><tt class="docutils literal"><span class="pre">filter(**kwargs)</span></tt><a class="headerlink" href="index.html#filter-kwargs" title="Permalink to this headline">¶</a></h4>
<p>返回一个新的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> ，它包含了与所给的筛选条件相匹配的对象。</p>
<p>这些筛选条件(<tt class="docutils literal"><span class="pre">**kwargs</span></tt>)在下面的<a class="reference internal" href="index.html#id7">字段筛选(Field lookups)</a> 中有详细介绍。多个条件之间在 SQL 语句中是 <tt class="docutils literal"><span class="pre">AND</span></tt> 关系。</p>
</div>
<div class="section" id="s-exclude-kwargs">
<span id="exclude-kwargs"></span><h4><tt class="docutils literal"><span class="pre">exclude(**kwargs)</span></tt><a class="headerlink" href="index.html#exclude-kwargs" title="Permalink to this headline">¶</a></h4>
<p>返回一个新的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>，它包含那些与所给筛选条件<b>不匹配</b>的对象。</p>
<p>这些筛选条件(<tt class="docutils literal"><span class="pre">**kwargs</span></tt>)也在下面的 <a class="reference internal" href="index.html#id7">字段筛选(Field lookups)</a> 中有详细描述。多个条件之间在 SQL 语句中也是 <tt class="docutils literal"><span class="pre">AND</span></tt> 关系，但是整体又是一个 <tt class="docutils literal"><span class="pre">NOT()</span></tt> 关系。</p>
<p>这个例子剔除了出版日期 <tt class="docutils literal"><span class="pre">pub_date</span></tt> 晚于 2005-1-3 并且大标题 <tt class="docutils literal"><span class="pre">headline</span></tt> 是 &quot;Hello&quot; 的所有博文(entry)：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">pub_date__gt</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mf">2005</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">3</span><span class="p">),</span> <span class="n">headline</span><span class="o">=</span><span class="s">&#39;Hello&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>在 SQL 语句中，这等价于：</p>
<div class="highlight-python"><pre>SELECT ...
WHERE NOT (pub_date &gt; '2005-1-3' AND headline = 'Hello')</pre>
</div>
<p>这个例子剔除出版日期 <tt class="docutils literal"><span class="pre">pub_date</span></tt> 晚于 2005-1-3 或者大标题是 &quot;Hello&quot; 的所有博文：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">pub_date__gt</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mf">2005</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">3</span><span class="p">))</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">&#39;Hello&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>在 SQL 语句中，这等价于：</p>
<div class="highlight-python"><pre>SELECT ...
WHERE NOT pub_date &gt; '2005-1-3'
OR NOT headline = 'Hello'</pre>
</div>
<p>要注意第二个例子是有很多限制的。</p>
</div>
<div class="section" id="s-annotate-args-kwargs">
<span id="annotate-args-kwargs"></span><h4><tt class="docutils literal"><span class="pre">注解annotate(*args,</span> <span class="pre">**kwargs)</span></tt><a class="headerlink" href="index.html#annotate-args-kwargs" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">这部分是 Django 1.1 新增的：</span> <a class="reference external" href="../../../releases/1.1/index.html#releases-1-1"><em>请查看版本文档。</em></a></div>
<p>我们可以为 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 中的每个对象添加注解。可以通过计算查询结果中每个对象所关联的对象集合，从而得出总计值(也可以是平均值或总和，等等)，做为 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 中对象的注解。<tt class="docutils literal"><span class="pre">annotate()</span></tt> 中的每个参数都会被做为注解添加到 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 中返回的对象。</p>
<p>Django 提供的注解函式在下面的 <a class="reference internal" href="index.html#id8">(注解函式Aggregation Functions)</a> 有详细介绍。</p>
<p>注解会使用关键字参数来做为注解的别名。其中任何参数都会生成一个别名，它与注解函式的名称和被注解的 model 相关。</p>
<p>例如，你正在操作一个博客列表，你想知道一个博客究竟有多少篇博文：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">))</span>
<span class="go"># The name of the first blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;Blogasaurus&#39;</span>
<span class="go"># The number of entries on the first blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">.</span><span class="n">entry__count</span>
<span class="go">42</span>
</pre></div>
</div>
<p> <tt class="docutils literal"><span class="pre">Blog</span></tt> model 类本身并没有定义 <tt class="docutils literal"><span class="pre">entry__count</span></tt> 属性，但可以使用注解函式的关系字参数，从而改变注解的命名：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">number_of_entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">))</span>
<span class="go"># The number of entries on the first blog, using the name provided</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">.</span><span class="n">number_of_entries</span>
<span class="go">42</span>
</pre></div>
</div>
<p>要深入了解注解，请参阅 <a class="reference external" href="../../../topics/db/aggregation/index.html#topics-db-aggregation"><em>注解指南(the topic guide on Aggregation)</em></a>。</p>
</div>
<div class="section" id="s-order-by-fields">
<span id="order-by-fields"></span><h4><tt class="docutils literal"><span class="pre">order_by(*fields)</span></tt><a class="headerlink" href="index.html#order-by-fields" title="Permalink to this headline">¶</a></h4>
<p>默认情况下， <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 返回的查询结果是根据 model 类的 <tt class="docutils literal"><span class="pre">Meta</span></tt> 设置所提供的 <tt class="docutils literal"><span class="pre">ordering</span></tt> 项中定义的排序元组来进行对象排序的。你可以使用 <tt class="docutils literal"><span class="pre">order_by</span></tt> 方法覆盖之前 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 中的排序设置。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mf">2005</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;-pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;headline&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>返回结果就会先按照 <tt class="docutils literal"><span class="pre">pub_date</span></tt> 进行升序排序，再按照 <tt class="docutils literal"><span class="pre">headline</span></tt> 进行降序排序。 <tt class="docutils literal"><span class="pre">&quot;-pub_date&quot;</span></tt> 前面的负号<b>&quot;?&quot;</b>表示<em><b>降序</b></em>排序。默认是采用升序排序。要随机排序，就使用 <tt class="docutils literal"><span class="pre">&quot;?&quot;</span></tt>，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;?&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>注意：<tt class="docutils literal"><span class="pre">order_by('?')</span></tt> 可能会非常缓慢和消耗过多资源，这取决于你所使用的数据库。</p>
<p>要根据其他 model 字段排序，所用语法和跨关系查询的语法相同。就是说，用两个连续的下划线(<tt class="docutils literal"><span class="pre">__</span></tt>)连接关联 model 和 要排序的字段名称, 而且可以一直延伸。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;blog__name&#39;</span><span class="p">,</span> <span class="s">&#39;headline&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你想对关联字段排序，在没有指定 <tt class="docutils literal"><span class="pre">Meta.ordering</span></tt> 的情况下，Django 会采用默认排序设置，就是按照关联 model 的主键进行排序。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;blog&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>...等价于：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;blog__id&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>...这是因为 <tt class="docutils literal"><span class="pre">Blog</span></tt> model 没有声明排序项的原故。</p>
<p>如果你使用了 <tt class="docutils literal"><span class="pre">distinct()</span></tt> 方法，那么在对关联字段排序时要格外谨慎。详情请查看 <a class="reference internal" href="index.html#distinct">distinct()</a> 一节了解在使用 <tt class="docutils literal"><span class="pre">distinct()</span></tt> 时，是如何对预期的排序结果产生意想不到的影响。</p>
<p>在 Django 当中是可以按照多值字段（例如 <tt class="docutils literal"><span class="pre">ManyToMany</span></tt> 字段）进行排序的。不过，这个特性虽然先进，但是并不实用。除非是你已经很清楚过滤结果或可用数据中的每个对象，都只有一个相关联的对象时（就是相当于只是一对一关系时），排序才会符合你预期的结果，所以对多值字段排序时要格外注意。</p>
<div class="versionadded">
<span class="title">这部分是在 Django 1.0 中新增的：</span> <a class="reference external" href="../../../releases/1.0/index.html#releases-1-0"><em>请查看版本文档</em></a></div>
<p>如果你不想对任何字段排序，也不想使用 model 中原有的排序设置，那么可以调用无参数的 <tt class="docutils literal"><span class="pre">order_by()</span></tt> 方法。</p>
<div class="versionadded">
<span class="title">这部分是在 Django 1.0 中新增的：</span> <a class="reference external" href="../../../releases/1.0/index.html#releases-1-0"><em>请查看版本文档</em></a></div>
<p>跨关系排序的语法已经改变，与 Django 0.96 有所不同，旧版本请查看 <a class="reference external" href="http://www.djangoproject.com/documentation/0.96/model-api/#floatfield">Django 0.96
documentation</a>。</p>
<p>对于排序项是否应该大小写敏感，Django 并没有提供设置方法，这完全取决于后端的数据库对排序大小写如何处理。</p>
<div class="versionadded">
<span class="title">这部分是在 Django 1.1 中新增的：</span> <a class="reference external" href="../../../releases/1.1/index.html#releases-1-1"><em>请查看版本文档</em></a></div>
<p>你可以令某个查询结果是可排序的，也可以是不可排序的，这取决于 <tt class="xref docutils literal"><span class="pre">QuerySet.ordered</span></tt> 属性。如果它的值是 <tt class="xref docutils literal"><span class="pre">True</span></tt> ，那么 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 就是可排序的。</p>
</div>
<div class="section" id="s-reverse">
<span id="reverse"></span><h4><tt class="docutils literal"><span class="pre">reverse()</span></tt><a class="headerlink" href="index.html#reverse" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">这部分是在 Django 1.0 中新增的：</span> <a class="reference external" href="../../../releases/1.0/index.html#releases-1-0"><em>请查看版本文档</em></a></div>
<p>使用 <tt class="docutils literal"><span class="pre">reverse()</span></tt> 方法会对查询结果进行反向排序。调用两次 <tt class="docutils literal"><span class="pre">reverse()</span></tt> 方法相当于排序没发生改过。</p>
<p>要得到查询结果中最后五个对象，可以这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">my_queryset</span><span class="o">.</span><span class="n">reverse</span><span class="p">()[:</span><span class="mf">5</span><span class="p">]</span>
</pre></div>
</div>
<p>要注意这种方式与 Python 语法中的从尾部切片是完全不一样的。在上面的例子中，是先得到最后一个元素，然后是倒数第二个，依次处理。但是如果我们有一个 Python 队列，使用 <tt class="docutils literal"><span class="pre">seq[-5:]</span></tt>时，却是先得到第五个元素。Django 之所以采用 <b>reverse</b> 来获取倒数的记录，而不支持切片的方法，原因就是后者在 SQL 中难以做好。</p>
<p>还有一点要注意，就是 <tt class="docutils literal"><span class="pre">reverse()</span></tt> 方法应该只作用于已定义了排序项 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> (例如，在查询时使用了<tt class="docutils literal"><span class="pre">order_by()</span></tt>方法，或是在 model 类当中直接定义了排序项). 如果并没有明确定义排序项，那么调用 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>, calling <tt class="docutils literal"><span class="pre">reverse()</span></tt> 就没什么实际意义（因为在调用 <tt class="docutils literal"><span class="pre">reverse()</span></tt> 之前，数据没有定义排序，所以在这之后也不会进行排序。)</p>
</div>
<div class="section" id="s-distinct">
<span id="s-querysets-distinct"></span><span id="distinct"></span><span id="querysets-distinct"></span><h4><tt class="docutils literal"><span class="pre">distinct()</span></tt><a class="headerlink" href="index.html#distinct" title="Permalink to this headline">¶</a></h4>
<p>返回一个新的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> ，它会在执行 SQL 查询时使用 <tt class="docutils literal"><span class="pre">SELECT</span> <span class="pre">DISTINCT</span></tt>。这意味着返回结果中的重复记录将被剔除。</p>
<p>默认情况下， <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 并会剔除重复的记录。在实际当中，这不是什么问题，因为象 <tt class="docutils literal"><span class="pre">Blog.objects.all()</span></tt> 这样的查询并不会产生重复的记录。但是，如果你使用 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 做多表查询时，就很可能会产生重复记录。这时，就可以使用 <tt class="docutils literal"><span class="pre">distinct()</span></tt> 方法。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>在 <a class="reference internal" href="index.html#order-by-fields">order_by(*fields)</a> 中出现的字段也会包含在 SQL <tt class="docutils literal"><span class="pre">SELECT</span></tt> 列中。如果和 <tt class="docutils literal"><span class="pre">distinct()</span></tt> 同时使用，有时返回的结果却与预想的不同。这是因为：如果你对跨关系的关联字段进行排序，这些字段就会被添加到被选取的列中，这就可能产生重复数据（比如，其他的列数据都相同，只是关联字段的值不同）。但由于 <b>order_by</b> 中的关联字段并不会出现在返回结果中（他们仅仅是用来实现order），所以有时返回的数据看上去就象是并没有进行过 <b>distinct</b> 处理一样。</p>
<p>同样的原因，如果你用 <tt class="docutils literal"><span class="pre">values()</span></tt> 方法获得被选取的列，就会发现包含在 <tt class="docutils literal"><span class="pre">order_by()</span></tt> (或是 model 类的 Meta 中设置的排序项)中的字段也包含在里面，就会对返回的结果产生影响。</p>
<p class="last">本节强调的就是在你使用 <tt class="docutils literal"><span class="pre">distinct()</span></tt> 时，要谨慎对待关联字段排序。同样的，在同时使用 <tt class="docutils literal"><span class="pre">distinct()</span></tt> 和 <tt class="docutils literal"><span class="pre">values()</span></tt> 时，如果排序字段并没有出现在 <tt class="docutils literal"><span class="pre">values()</span></tt> 返回的结果中，那么也要引起注意。</p>
</div>
</div>
<div class="section" id="s-values-fields">
<span id="values-fields"></span><h4><tt class="docutils literal"><span class="pre">values(*fields)</span></tt><a class="headerlink" href="index.html#values-fields" title="Permalink to this headline">¶</a></h4>
<p>返回一个 <tt class="docutils literal"><span class="pre">ValuesQuerySet</span></tt> -- 它是一个特殊的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> ，运行后得到的并不是一系列 model 的实例化对象，而是一个字典列表。</p>
<p>每个字典都表示一个对象，而键名就是 model 对象的属性名称。</p>
<p>下面的例子就对 <tt class="docutils literal"><span class="pre">values()</span></tt> 得到的字典与传统的 model 对象进行了对比：</p>
<div class="highlight-python"><pre># This list contains a Blog object.
&gt;&gt;&gt; Blog.objects.filter(name__startswith='Beatles')
[&lt;Blog: Beatles Blog&gt;]

# This list contains a dictionary.
&gt;&gt;&gt; Blog.objects.filter(name__startswith='Beatles').values()
[{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]</pre>
</div>
<p><tt class="docutils literal"><span class="pre">values()</span></tt> 可以接收可选的位置参数，<tt class="docutils literal"><span class="pre">*fields</span></tt>，就是字段的名称，用来限制 <tt class="docutils literal"><span class="pre">SELECT</span></tt> 选取的数据。如果你指定了字段参数，每个字典就会以 Key-Value 的形式保存你所指定的字段信息；如果没有指定，每个字典就会包含当前数据表当中的所有字段信息。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="go">[{&#39;id&#39;: 1, &#39;name&#39;: &#39;Beatles Blog&#39;, &#39;tagline&#39;: &#39;All the latest Beatles news.&#39;}],</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">)</span>
<span class="go">[{&#39;id&#39;: 1, &#39;name&#39;: &#39;Beatles Blog&#39;}]</span>
</pre></div>
</div>
<p>下面这些细节值得注意：</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">values()</span></tt> 方法不返回 <a title="django.db.models.ManyToManyField" class="reference external" href="../fields/index.html#django.db.models.ManyToManyField"><tt class="xref docutils literal"><span class="pre">ManyToManyField</span></tt></a> 属性的任何信息，如果你把 <a title="django.db.models.ManyToManyField" class="reference external" href="../fields/index.html#django.db.models.ManyToManyField"><tt class="xref docutils literal"><span class="pre">ManyToManyField</span></tt></a> 的名称做为参数传递给 <tt class="docutils literal"><span class="pre">values()</span></tt>，就会抛出异常。</p>
</li>
<li><p class="first">如果你有一个名为 <tt class="docutils literal"><span class="pre">foo</span></tt> 的<a title="django.db.models.ForeignKey" class="reference external" href="../fields/index.html#django.db.models.ForeignKey"><tt class="xref docutils literal"><span class="pre">ForeignKey</span></tt></a> 字段，默认情况下调用 <tt class="docutils literal"><span class="pre">values()</span></tt> 返回的字典中包含键名为 <tt class="docutils literal"><span class="pre">foo_id</span></tt> 的字典项，因为它是一个隐含的 model 字段，用来保存关联对象的主键值( <tt class="docutils literal"><span class="pre">foo</span></tt> 属性用来联系相关联的 model )。当你使用 <tt class="docutils literal"><span class="pre">values()</span></tt> 并传递字段名称时， 传递<tt class="docutils literal"><span class="pre">foo</span></tt> 或 <tt class="docutils literal"><span class="pre">foo_id</span></tt> 都会得到相同的结果 (字典中的键名会自动换成你传递的字段名称)。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="go">[{&#39;blog_id: 1, &#39;headline&#39;: u&#39;First Entry&#39;, ...}, ...]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;blog&#39;</span><span class="p">)</span>
<span class="go">[{&#39;blog&#39;: 1}, ...]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;blog_id&#39;</span><span class="p">)</span>
<span class="go">[{&#39;blog_id&#39;: 1}, ...]</span>
</pre></div>
</div>
</li>
<li><p class="first">在 <tt class="docutils literal"><span class="pre">values()</span></tt> 和 <tt class="docutils literal"><span class="pre">distinct()</span></tt> 同时使用时，要注意排序项会影响返回的结果，详情请查看上面 <a class="reference internal" href="index.html#distinct">distinct()</a> 一节。</p>
</li>
</ul>
<div class="versionadded">
<span class="title">这部分是在 Django 1.0 中新增的：</span> <a class="reference external" href="../../../releases/1.0/index.html#releases-1-0"><em>详情请查阅版本文档</em></a></div>
<p>前面所提到的，在 <tt class="docutils literal"><span class="pre">values()</span></tt> 中使用 <tt class="docutils literal"><span class="pre">blog_id</span></tt> 是无效的，只能用 <tt class="docutils literal"><span class="pre">blog</span></tt>。这是 Django 1.0 及后续版本的用法。</p>
<p><tt class="docutils literal"><span class="pre">ValuesQuerySet</span></tt> 是非常有用的。利用它，你就可以只获得你所需的那部分数据，而不必同时读取其他的无用数据。</p>
<p>最后，要提醒的是，<tt class="docutils literal"><span class="pre">ValuesQuerySet</span></tt> 是 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的一个子类，所以它拥有 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 所有的方法。你可以对它调用 <tt class="docutils literal"><span class="pre">filter()</span></tt> 或是 <tt class="docutils literal"><span class="pre">order_by()</span></tt> 以及其他方法。所以下面俩种写法是等价的：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">()</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span>
<span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
</pre></div>
</div>
<p>Django 的编写者们更喜欢第二种写法，就是先写影响 SQL 的方法，再写影响输出的方法（比如例中先写 order，再写values ），但这些都无关紧要，完全视你个人喜好而定。</p>
</div>
<div class="section" id="s-values-list-fields">
<span id="values-list-fields"></span><h4><tt class="docutils literal"><span class="pre">values_list(*fields)</span></tt><a class="headerlink" href="index.html#values-list-fields" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">这部分是在 Django 1.0 中新增的：</span> <a class="reference external" href="../../../releases/1.0/index.html#releases-1-0"><em>请查阅版本文档</em></a></div>
<p>它与 <tt class="docutils literal"><span class="pre">values()</span></tt> 非常相似，只不过后者返回的结果是字典列表，而 <tt class="docutils literal"><span class="pre">values()</span></tt> 返回的结果是元组列表。每个元组都包含传递给 <tt class="docutils literal"><span class="pre">values_list()</span></tt> 的字段名称和内容。比如第一项就对应着第一个字段，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="s">&#39;headline&#39;</span><span class="p">)</span>
<span class="go">[(1, u&#39;First entry&#39;), ...]</span>
</pre></div>
</div>
<p>如果你传递了一个字段做为参数，那么你可以使用 <tt class="docutils literal"><span class="pre">flat</span></tt> 参数。如果它的值是 <tt class="xref docutils literal"><span class="pre">True</span></tt>，就意味着返回结果都是单独的值，而不是元组。下面的例子会讲得更清楚：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span>
<span class="go">[(1,), (2,), (3,), ...]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span>
<span class="go">[1, 2, 3, ...]</span>
</pre></div>
</div>
<p>如果传递的字段不止一个，使用 <tt class="docutils literal"><span class="pre">flat</span></tt> 就会导致错误。</p>
<p>如果你没给 <tt class="docutils literal"><span class="pre">values_list()</span></tt> 传递参数，它就会按照字段在 model 类中定义的顺序返回所有的字段。</p>
</div>
<div class="section" id="s-dates-field-kind-order-asc">
<span id="dates-field-kind-order-asc"></span><h4><tt class="docutils literal"><span class="pre">dates(field,</span> <span class="pre">kind,</span> <span class="pre">order='ASC')</span></tt><a class="headerlink" href="index.html#dates-field-kind-order-asc" title="Permalink to this headline">¶</a></h4>
<p>返回一个 <tt class="docutils literal"><span class="pre">DateQuerySet</span></tt> ，就是提取 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 查询中所包含的日期，将其组成一个新的 <tt class="docutils literal"><span class="pre">datetime.datetime</span></tt> 对象的列表。</p>
<p><tt class="docutils literal"><span class="pre">field</span></tt> 是你的 model 中的 <tt class="docutils literal"><span class="pre">DateField</span></tt> 或 <tt class="docutils literal"><span class="pre">DateTimeField</span></tt> 字段名称。</p>
<p><tt class="docutils literal"><span class="pre">kind</span></tt> 是 <tt class="docutils literal"><span class="pre">&quot;year&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;month&quot;</span></tt> 或 <tt class="docutils literal"><span class="pre">&quot;day&quot;</span></tt> 之一。 每个 <tt class="docutils literal"><span class="pre">datetime.datetime</span></tt> 对象都会根据所给的 <tt class="docutils literal"><span class="pre">type</span></tt> 进行截减。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">&quot;year&quot;</span></tt> 返回所有时间值中非重复的年分列表。</li>
<li><tt class="docutils literal"><span class="pre">&quot;month&quot;</span></tt> 返回所有时间值中非重复的年／月列表。</li>
<li><tt class="docutils literal"><span class="pre">&quot;day&quot;</span></tt> 返回所有时间值中非重复的年／月／日列表。</li>
</ul>
<p><tt class="docutils literal"><span class="pre">order</span></tt>, 默认是 <tt class="docutils literal"><span class="pre">'ASC'</span></tt>，只有两个取值 <tt class="docutils literal"><span class="pre">'ASC'</span></tt> 或 <tt class="docutils literal"><span class="pre">'DESC'</span></tt>。它决定结果如何排序。</p>
<p>例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">dates</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;year&#39;</span><span class="p">)</span>
<span class="go">[datetime.datetime(2005, 1, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">dates</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;month&#39;</span><span class="p">)</span>
<span class="go">[datetime.datetime(2005, 2, 1), datetime.datetime(2005, 3, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">dates</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;day&#39;</span><span class="p">)</span>
<span class="go">[datetime.datetime(2005, 2, 20), datetime.datetime(2005, 3, 20)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">dates</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;day&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;DESC&#39;</span><span class="p">)</span>
<span class="go">[datetime.datetime(2005, 3, 20), datetime.datetime(2005, 2, 20)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dates</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;day&#39;</span><span class="p">)</span>
<span class="go">[datetime.datetime(2005, 3, 20)]</span>
</pre></div>
</div>
</div>
<div class="section" id="s-none">
<span id="none"></span><h4><tt class="docutils literal"><span class="pre">none()</span></tt><a class="headerlink" href="index.html#none" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">这部分是在 Django 1.0 中新增的：</span> <a class="reference external" href="../../../releases/1.0/index.html#releases-1-0"><em>请查看版本文档</em></a></div>
<p>返回一个 <tt class="docutils literal"><span class="pre">EmptyQuerySet</span></tt> -- 它是一个运行时只返回空列表的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>。它经常用在这种场合：你要返回一个空列表，但是调用者却需要接收一个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 对象。（这时，就可以用它代替空列表）</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">none</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</div>
<div class="section" id="s-all">
<span id="all"></span><h4><tt class="docutils literal"><span class="pre">all()</span></tt><a class="headerlink" href="index.html#all" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">这部分是在 Django 1.0 中新增的：</span> <a class="reference external" href="../../../releases/1.0/index.html#releases-1-0"><em>请查看版本文档</em></a></div>
<p>返回当前 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> (或者是传递的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 子类)的一分拷贝。 这在某些场合是很用的，比如，你想对一个 model manager 或是一个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的查询结果做进一步的过滤。你就可以调用 <tt class="docutils literal"><span class="pre">all()</span></tt> 获得一分拷贝以继续操作，从而保证原 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的安全。</p>
</div>
<div class="section" id="s-id4">
<span id="s-select-related"></span><span id="id4"></span><span id="select-related"></span><h4><tt class="docutils literal"><span class="pre">select_related()</span></tt><a class="headerlink" href="index.html#id4" title="Permalink to this headline">¶</a></h4>
<p>返回一个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> ，它会在执行查询时自动跟踪外键关系，从而选取所关联的对象数据。它是一个增效器，虽然会导致较大的数据查询（有时会非常大），但是接下来再使用外键关系获得关联对象时，就会不再次读取数据库了。</p>
<p>下面的例子展示在获得关联对象时，使用 <tt class="docutils literal"><span class="pre">select_related()</span></tt> 和不使用的区别，首先是不使用的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Hits the database.</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">5</span><span class="p">)</span>

<span class="c"># Hits the database again to get the related Blog object.</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">blog</span>
</pre></div>
</div>
<p>接下来是使用 <tt class="docutils literal"><span class="pre">select_related</span></tt> 的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Hits the database.</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">5</span><span class="p">)</span>

<span class="c"># Doesn&#39;t hit the database, because e.blog has been prepopulated</span>
<span class="c"># in the previous query.</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">blog</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">select_related()</span></tt> 会尽可能地深入遍历外键连接。例如：</p>
<div class="highlight-python"><pre>class City(models.Model):
    # ...

class Person(models.Model):
    # ...
    hometown = models.ForeignKey(City)

class Book(models.Model):
    # ...
    author = models.ForeignKey(Person)</pre>
</div>
<p>...接下来调用 <tt class="docutils literal"><span class="pre">Book.objects.select_related().get(id=4)</span></tt> 将缓存关联的 <tt class="docutils literal"><span class="pre">Person</span></tt> <b>和</b> <tt class="docutils literal"><span class="pre">City</span></tt>：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">4</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">author</span>         <span class="c"># Doesn&#39;t hit the database.</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">hometown</span>       <span class="c"># Doesn&#39;t hit the database.</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">4</span><span class="p">)</span> <span class="c"># No select_related() in this example.</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">author</span>         <span class="c"># Hits the database.</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">hometown</span>       <span class="c"># Hits the database.</span>
</pre></div>
</div>
<p>要注意的是，默认情况下，<tt class="docutils literal"><span class="pre">select_related()</span></tt> 并不跟踪 <tt class="docutils literal"><span class="pre">null=True</span></tt> 的外键关系。</p>
<p>一般情况下，使用 <tt class="docutils literal"><span class="pre">select_related()</span></tt> 会极大的改善性能，因为它可以避免过多的数据库操作。但是，在关系嵌套深度过多的情况下，<tt class="docutils literal"><span class="pre">select_related()</span></tt> 有时会结束对关系的跟踪，而且因为生成的查询会非常大大，会导致操作变慢。</p>
<p>在这种情况下，你可以使用 <tt class="docutils literal"><span class="pre">depth</span></tt> 参数，添加到 <tt class="docutils literal"><span class="pre">select_related()</span></tt>中从而控制要跟踪的关系层数：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">4</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">author</span>         <span class="c"># Doesn&#39;t hit the database.</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">hometown</span>       <span class="c"># Requires a database call.</span>
</pre></div>
</div>
<p>有时，你的 model 中有多个关联字段，而你只想一性访问其中的某几个，这时你就可以将这些字段的名称做为参数传递给 <tt class="docutils literal"><span class="pre">select_related()</span></tt> ，然后就只有它们所关联的关系被跟踪。你甚至可以象使用过滤器那样，在其中使用双下划线来表示 model 之间的关联，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Room</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="n">building</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="n">teacher</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">room</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Room</span><span class="p">)</span>
    <span class="n">subject</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>...如果你只想跟踪 <tt class="docutils literal"><span class="pre">room</span></tt> 和 <tt class="docutils literal"><span class="pre">subject</span></tt> 属性，可以这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">Group</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">&#39;room&#39;</span><span class="p">,</span> <span class="s">&#39;subject&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这样写也是正确的：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">Group</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">&#39;room__building&#39;</span><span class="p">,</span> <span class="s">&#39;subject&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>...这样也会将 <tt class="docutils literal"><span class="pre">building</span></tt> 关系加入到跟踪中。</p>
<p>你只能将外键字段 <tt class="docutils literal"><span class="pre">ForeignKey</span></tt> 传递给
<tt class="docutils literal"><span class="pre">select_related</span></tt>。你<b>可以</b>用传递名称做为参数，用来连接 <tt class="docutils literal"><span class="pre">null=True</span></tt> 的外链关系
(与默认的 <tt class="docutils literal"><span class="pre">select_related()</span></tt> 不同)。如果你在同一个 <tt class="docutils literal"><span class="pre">select_related()</span></tt> 中同时使用字段名称和 <tt class="docutils literal"><span class="pre">depth</span></tt> 参数，就会导致错误，因为他们是矛盾的两个选项。</p>
<div class="versionadded">
<span class="title">这部分是在 Django 1.0 中新增的：</span> <a class="reference external" href="../../../releases/1.0/index.html#releases-1-0"><em>请查看版本文档</em></a></div>
<p>在 <tt class="docutils literal"><span class="pre">select_related()</span></tt> 中同时使用 <tt class="docutils literal"><span class="pre">depth</span></tt> 参数和指定关联字段名称在 Django 1.0 及其后续版本中是可用的。</p>
</div>
<div class="section" id="s-extra-select-none-where-none-params-none-tables-none-order-by-none-select-params-none">
<span id="s-extra"></span><span id="extra-select-none-where-none-params-none-tables-none-order-by-none-select-params-none"></span><span id="extra"></span><h4><tt class="docutils literal"><span class="pre">extra(select=None,</span> <span class="pre">where=None,</span> <span class="pre">params=None,</span> <span class="pre">tables=None,</span> <span class="pre">order_by=None,</span> <span class="pre">select_params=None)</span></tt><a class="headerlink" href="index.html#extra-select-none-where-none-params-none-tables-none-order-by-none-select-params-none" title="Permalink to this headline">¶</a></h4>
<p>有些情况下，Django 的查询语法难以简练地表达复杂的 <tt class="docutils literal"><span class="pre">WHERE</span></tt> 子句。对于这种情况，Django 提供了 <tt class="docutils literal"><span class="pre">extra()</span></tt>
<tt class="docutils literal"><span class="pre">QuerySet</span></tt> 修改机制，它能在<tt class="docutils literal"><span class="pre">QuerySet</span></tt> 生成的 SQL 从句中注入新子句。</p>
<p>由于产品差异的原因，这些自定义的查询难以保障在不同的数据库之间兼容(因为你手写 SQL 代码的原因)，而且违背了 DRY 原则，所以如非必要，还是尽量避免写 <b>extra</b>。</p>
<p>在 <b>extra</b> 可以指定一个或多个 <tt class="docutils literal"><span class="pre">params</span></tt> 参数，如 <tt class="docutils literal"><span class="pre">select</span></tt>，<tt class="docutils literal"><span class="pre">where</span></tt> 或 <tt class="docutils literal"><span class="pre">tables</span></tt>。所有参数都是可选的，但你至少要使用一个。</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">select</span></tt></dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">select</span></tt> 参数可以让你在 <tt class="docutils literal"><span class="pre">SELECT</span></tt> 从句中添加其他字段信息。它应该是一个字典，存放着属性名到 SQL 从句的映射。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;is_recent&#39;</span><span class="p">:</span> <span class="s">&quot;pub_date &gt; &#39;2006-01-01&#39;&quot;</span><span class="p">})</span>
</pre></div>
</div>
<p>结果中每个 <tt class="docutils literal"><span class="pre">Entry</span></tt> 对象都有一个额外的 <tt class="docutils literal"><span class="pre">is_recent</span></tt> 属性，它是一个布尔值，表示 <tt class="docutils literal"><span class="pre">pub_date</span></tt> 是否晚于2006年1月1号。</p>
<p>Django 会直接在 <tt class="docutils literal"><span class="pre">SELECT</span></tt> 中加入对应的 SQL 片断，所以转换后的 SQL 如下：</p>
<div class="highlight-python"><pre>SELECT blog_entry.*, (pub_date &gt; '2006-01-01')
FROM blog_entry;</pre>
</div>
<p>下面这个例子更复杂一些；它会在每个 <tt class="docutils literal"><span class="pre">Blog</span></tt> 对象中添加一个 <tt class="docutils literal"><span class="pre">entry_count</span></tt> 属性，它会运行一个子查询，得到相关联的 <tt class="docutils literal"><span class="pre">Entry</span></tt> 对象的数量：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
    <span class="n">select</span><span class="o">=</span><span class="p">{</span>
        <span class="s">&#39;entry_count&#39;</span><span class="p">:</span> <span class="s">&#39;SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id&#39;</span>
    <span class="p">},</span>
<span class="p">)</span>
</pre></div>
</div>
<p>(在上面这个特例中，我们要了解这个事实，就是 <tt class="docutils literal"><span class="pre">blog_blog</span></tt> 表已经存在于 <tt class="docutils literal"><span class="pre">FROM</span></tt> 从句中。)</p>
<p>翻译成 SQL 如下：</p>
<div class="highlight-python"><pre>SELECT blog_blog.*, (SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id) AS entry_count
FROM blog_blog;</pre>
</div>
<p>要注意的是，大多数数据库需要在子句两端添加括号，而在 Django 的 <tt class="docutils literal"><span class="pre">select</span></tt> 从句中却无须这样。同样要引起注意的是，在某些数据库中，比如某些 MySQL 版本，是不支持子查询的。</p>
<div class="versionadded">
<span class="title">这部分是在 Django 1.0 中新增的：</span> <a class="reference external" href="../../../releases/1.0/index.html#releases-1-0"><em>请查看版本文档</em></a></div>
<p>某些时候，你可能想给 <tt class="docutils literal"><span class="pre">extra(select=...)</span></tt> 中的 SQL 语句传递参数，这时就可以使用 <tt class="docutils literal"><span class="pre">select_params</span></tt> 参数。因为 <tt class="docutils literal"><span class="pre">select_params</span></tt> 是一个队列，而 <tt class="docutils literal"><span class="pre">select</span></tt> 属性是一个字典，所以两者在匹配时应正确地一一对应。在这种情况下中，你应该使用 <tt class="docutils literal"><span class="pre">django.utils.datastructures.SortedDict</span></tt> 匹配 <tt class="docutils literal"><span class="pre">select</span></tt> 的值，而不是使用一般的 Python 队列。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
    <span class="n">select</span><span class="o">=</span><span class="n">SortedDict</span><span class="p">([(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span><span class="p">)]),</span>
    <span class="n">select_params</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;one&#39;</span><span class="p">,</span> <span class="s">&#39;two&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p class="last">在使用 <tt class="docutils literal"><span class="pre">extra()</span></tt> 时要避免在 select 字串含有 <tt class="docutils literal"><span class="pre">&quot;%%s&quot;</span></tt> 子串， 这是因为在 Django 中，处理 select 字串时查找的是 <tt class="docutils literal"><span class="pre">%s</span></tt> 而并非转义后的 <tt class="docutils literal"><span class="pre">%</span></tt> 字符。所以如果对 <b>%</b> 进行了转义，反而得不到正确的结果。</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">where</span></tt> / <tt class="docutils literal"><span class="pre">tables</span></tt></dt>
<dd><p class="first">你可以使用 <tt class="docutils literal"><span class="pre">where</span></tt> 参数显示定义 SQL 中的 <tt class="docutils literal"><span class="pre">WHERE</span></tt> 从句，有时也可以运行非显式地连接。你还可以使用 <tt class="docutils literal"><span class="pre">tables</span></tt> 手动地给 SQL <tt class="docutils literal"><span class="pre">FROM</span></tt> 从句添加其他表。</p>
<p><tt class="docutils literal"><span class="pre">where</span></tt> 和 <tt class="docutils literal"><span class="pre">tables</span></tt> 都接受字符串列表做为参数。所有的 <tt class="docutils literal"><span class="pre">where</span></tt> 参数彼此之间都是 <b>&quot;AND&quot;</b> 关系。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;id IN (3, 4, 5, 20)&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>...大致可以翻译为如下的 SQL:</p>
<div class="highlight-python"><pre>SELECT * FROM blog_entry WHERE id IN (3, 4, 5, 20);</pre>
</div>
    <p>
下面这个是 tables 的例子:
</p>
<pre class="wiki">queryset.extra(tables=['(select * from table) as k'])
</pre><p>
翻译的 SQL 如下：
</p>
<pre class="wiki">select ........ from `self_table`, `(select * from table) as k`
</pre><p>
这展示了如何运行子查询。
</p>
<p>在使用 <tt class="docutils literal"><span class="pre">tables</span></tt> 时，如果你指定的表在查询中已出现过，那么要格外小心。当你通过 <tt class="docutils literal"><span class="pre">tables</span></tt> 参数添加其他数据表时，如果这个表已经被包含在查询中，那么 Django 就会认为你想再一次包含这个表。这就导致了一个问题：由于重复出现多次的表会被赋予一个别名，所以除了第一次之外，每个重复的表名都会分别由 Django 分配一个别名。所以，如果你同时使用了 <tt class="docutils literal"><span class="pre">where</span></tt> 参数，在其中用到了某个重复表，却不知它的别名，那么就会导致错误。</p>
<p class="last">一般情况下，你只会添加一个未在查询中出现的新表。但是如果上面所提到的特殊情况发生了，那么可以采用如下措施解决。首先，判断是否有必要要出现重复的表，能否将重复的表去掉。如果这点行不通，就试着把 <tt class="docutils literal"><span class="pre">extra()</span></tt> 调用放在查询结构的起始处，因为首次出现的表名不会被重命名，所以可能能解决问题。如果这也不行，那就查看生成的 SQL 语句，从中找出各个数据库的别名，然后依此重写 <tt class="docutils literal"><span class="pre">where</span></tt> 参数，因为只要你每次都用同样的方式调用查询(queryset)，表的别名都不会发生变化。所以你可以直接使用表的别名来构造 <tt class="docutils literal"><span class="pre">where</span></tt>。</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">order_by</span></tt></dt>
<dd><p class="first">如果你已通过 <tt class="docutils literal"><span class="pre">extra()</span></tt> 添加了新字段或是数据库，此时若想对新字段进行排序，就可以给 <tt class="docutils literal"><span class="pre">extra()</span></tt> 中的 <tt class="docutils literal"><span class="pre">order_by</span></tt> 参数传递一个排序字符串序列。字符串可以是 model 原生的字段名(与使用普通的 <tt class="docutils literal"><span class="pre">order_by()</span></tt> 方法一样)，也可以是 <tt class="docutils literal"><span class="pre">table_name.column_name</span></tt> 这种形式，或者是你在 <tt class="docutils literal"><span class="pre">extra()</span></tt> 的 <tt class="docutils literal"><span class="pre">select</span></tt> 中所定义的字段。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">q</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;is_recent&#39;</span><span class="p">:</span> <span class="s">&quot;pub_date &gt; &#39;2006-01-01&#39;&quot;</span><span class="p">})</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">order_by</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;-is_recent&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>这段代码按照 <tt class="docutils literal"><span class="pre">is_recent</span></tt> 对记录进行排序，字段值是 <b>True</b> 的排在前面，<b>False</b> 的排在后面。(<tt class="xref docutils literal"><span class="pre">True</span></tt> 在降序排序时是排在 <tt class="xref docutils literal"><span class="pre">False</span></tt> 的前面)。</p>
<p class="last">顺便说一下，上面这段代码同时也展示出，可以依你所愿的那样多次调用 <tt class="docutils literal"><span class="pre">extra()</span></tt> 操作(每次添加新的语句结构即可)。</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">params</span></tt></dt>
<dd><p class="first">上面提到的 <tt class="docutils literal"><span class="pre">where</span></tt> 参数还可以用标准的 Python 占位符 -- <tt class="docutils literal"><span class="pre">'%s'</span></tt> ，它可以根据数据库引擎自动决定是否添加引号。 <tt class="docutils literal"><span class="pre">params</span></tt> 参数是用来替换占位符的字符串列表。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;headline=</span><span class="si">%s</span><span class="s">&#39;</span><span class="p">],</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;Lennon&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>使用 <tt class="docutils literal"><span class="pre">params</span></tt> 替换 <tt class="docutils literal"><span class="pre">where</span></tt> 的中嵌入值是一个非常好的做法，这是因为 <tt class="docutils literal"><span class="pre">params</span></tt> 可以根据你的数据库判断要不要给传入值添加引号（例如，传入值中的引号会被自动转义）。</p>
<p>不好的用法：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;headline=&#39;Lennon&#39;&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>优雅的用法：</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;headline=</span><span class="si">%s</span><span class="s">&#39;</span><span class="p">],</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;Lennon&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="s-defer-fields">
<span id="s-queryset-defer"></span><span id="defer-fields"></span><span id="queryset-defer"></span><h4><tt class="docutils literal"><span class="pre">defer(*fields)</span></tt><a class="headerlink" href="index.html#defer-fields" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">这部分是在 Django 1.1 中新增的：</span> <a class="reference external" href="../../../releases/1.1/index.html#releases-1-1"><em>请查看版本文档</em></a></div>
<p>在某些数据复杂的环境下，你的 model 可能包含非常多的字段，可能某些字段包含非常多的数据(比如，文档字段)，或者将其转化为 Python 对象会消耗非常多的资源。在这种情况下，有时你可能并不需要这种字段的信息，那么你可以让 Django 不读取它们的数据。</p>
<p>将不想载入的字段的名称传给 <tt class="docutils literal"><span class="pre">defer()</span></tt> 方法，就可以做到延后载入：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;lede&quot;</span><span class="p">,</span> <span class="s">&quot;body&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>延后截入字段的查询返回的仍是 model 类的实例。在你访问延后载入字段时，你仍可以获得字段的内容，所不同的是，内容是在你访问延后字段时才读取数据库的，而普通字段是在运行查询(queryset)时就一次性从数据库中读取数据的。</p>
<p>你可以多次调用 <tt class="docutils literal"><span class="pre">defer()</span></tt> 方法。每个调用都可以添加新的延后载入字段：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Defers both the body and lede fields.</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">&quot;Lennon&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;lede&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>对延后载入字段进行排序是不会起作用的；重复添加延后载入字段也不会有何不良影响。</p>
<p>你也可以延后载入关联 model 中的字段(前提是你使用 <tt class="docutils literal"><span class="pre">select_related()</span></tt> 载入了关联 model)，用法也是用双下划线连接关联字段：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">()</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;entry__lede&quot;</span><span class="p">,</span> <span class="s">&quot;entry__body&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你想清除延后载入的设置，只要使用将 <tt class="xref docutils literal"><span class="pre">None</span></tt> 做为参数传给 <tt class="docutils literal"><span class="pre">defer()</span></tt> 即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Load all fields immediately.</span>
<span class="n">my_queryset</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>有些字段无论你如何指定，都不会被延后加载。比如，你永远不能延后加载主键字段。如果你使用 <tt class="docutils literal"><span class="pre">select_related()</span></tt> 获得关联 model 字段信息，那么你就不能延后载入关联 model 的主键。（如果这样做了，虽然不会抛出错误，事实上却不完成延后加载）</p>
<div class="admonition note">
<p class="first admonition-title">注意</p>
<p class="last"> <tt class="docutils literal"><span class="pre">defer()</span></tt> 方法(和随后提到的 <tt class="docutils literal"><span class="pre">only()</span></tt> 方法) 都只适用于特定情况下的高级属性。它们可以提供性能上的优化，不过前提是你已经对你用到的查询有过很深入细致的分析，非常清楚你需要的究竟是哪些信息，而且已经对你所需要的数据和默认情况下返回的所有数据进行比对，清楚两者之间的差异。这完成了上述工作之后，再使用这两种方法进行优化才是有意义的。所以当你刚开始构建你的应用时，先不要急着使用 <tt class="docutils literal"><span class="pre">defer()</span></tt> 方法，等你已经写完查询并且分析成哪些方面是热点应用以后，再用也不迟。</p>
</div>
</div>
<div class="section" id="s-only-fields">
<span id="only-fields"></span><h4><tt class="docutils literal"><span class="pre">only(*fields)</span></tt><a class="headerlink" href="index.html#only-fields" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">这部分是在 Django 1.1 中新增的：</span> <a class="reference external" href="../../../releases/1.1/index.html#releases-1-1"><em>请查看版本文档</em></a></div>
<p> <tt class="docutils literal"><span class="pre">only()</span></tt> 方法或多或少与 <tt class="docutils literal"><span class="pre">defer()</span></tt> 的作用相反。如果你在提取数据时希望某个字段不应该被延后载入，而应该立即载入，那么你就可以做使用 <tt class="docutils literal"><span class="pre">only()</span></tt> 方法。如果你一个 model ，你希望它所有的字段都延后加载，只有某几个字段是立即载入的，那么你就应该使用 <b>only()</b> 方法。</p>
<p>如果你有一个 model，它有 <tt class="docutils literal"><span class="pre">name</span></tt>, <tt class="docutils literal"><span class="pre">age</span></tt> 和 <tt class="docutils literal"><span class="pre">biography</span></tt> 三个字段，那么下面两种写法效果一样的：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;age&quot;</span><span class="p">,</span> <span class="s">&quot;biography&quot;</span><span class="p">)</span>
<span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>你无论何时调用 <tt class="docutils literal"><span class="pre">only()</span></tt>，它都会<b>立刻更改</b>载入设置。这与它的命名非常相符：<em>只有</em> <strong>only</strong> 中的字段会立即载入，而其他的则都是延后载入的。因此，连续调用 <tt class="docutils literal"><span class="pre">only()</span></tt> 时，只有最后一个 <b>only</b> 方法才会生效：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># This will defer all fields except the headline.</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">,</span> <span class="s">&quot;lede&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="s">&quot;headline&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>由于 <tt class="docutils literal"><span class="pre">defer()</span></tt> 可以递增（每次都添加字段到延后载入的列表中），所以你可以将 <tt class="docutils literal"><span class="pre">only()</span></tt> 和 <tt class="docutils literal"><span class="pre">defer()</span></tt> 结合在一起使用，请注意使用顺序，先 <b>only</b> 而后 <b>defer</b>：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Final result is that everything except &quot;headline&quot; is deferred.</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="s">&quot;headline&quot;</span><span class="p">,</span> <span class="s">&quot;body&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">)</span>

<span class="c"># Final result loads headline and body immediately (only() replaces any</span>
<span class="c"># existing set of fields).</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="s">&quot;headline&quot;</span><span class="p">,</span> <span class="s">&quot;body&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-queryset-methods-that-do-not-return-querysets">
<span id="queryset-methods-that-do-not-return-querysets"></span><h3>不返回查询的方法(QuerySet methods that do not return QuerySets)<a class="headerlink" href="index.html#queryset-methods-that-do-not-return-querysets" title="Permalink to this headline">¶</a></h3>
<p>下面所列的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 方法作用于 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>，却并不返回 <em>other than</em> a <tt class="docutils literal"><span class="pre">QuerySet</span></tt>。</p>
<p>这些方法并不使用缓存(请查看 <a class="reference external" href="../../../topics/db/queries/index.html#caching-and-querysets"><em>缓存与查询(Caching and QuerySets)</em></a>)。所以它们在运行时是立即读取数据库的。</p>
<div class="section" id="s-id5">
<span id="s-get-kwargs"></span><span id="id5"></span><span id="get-kwargs"></span><h4><tt class="docutils literal"><span class="pre">get(**kwargs)</span></tt><a class="headerlink" href="index.html#id5" title="Permalink to this headline">¶</a></h4>
<p>返回与所给的筛选条件相匹配的对象，筛选条件在 <a class="reference internal" href="index.html#id7">字段筛选条件(Field lookups)</a> 一节中有详细介绍。</p>
<p>在使用 <tt class="docutils literal"><span class="pre">get()</span></tt> 时，如果符合筛选条件的对象超过一个，就会抛出 <tt class="docutils literal"><span class="pre">MultipleObjectsReturned</span></tt> 异常。<tt class="docutils literal"><span class="pre">MultipleObjectsReturned</span></tt> 是 model 类的一个属性。</p>
<p>在使用 <tt class="docutils literal"><span class="pre">get()</span></tt> 时，如果没有找到符合筛选条件的对象，就会抛出 <tt class="docutils literal"><span class="pre">DoesNotExist</span></tt> 异常。这个异常也是 model 对象的一个属性。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">&#39;foo&#39;</span><span class="p">)</span> <span class="c"># raises Entry.DoesNotExist</span>
</pre></div>
</div>
<p> <tt class="docutils literal"><span class="pre">DoesNotExist</span></tt> 异常继承自 <tt class="docutils literal"><span class="pre">django.core.exceptions.ObjectDoesNotExist</span></tt>，所以你可以直接截获 <tt class="docutils literal"><span class="pre">DoesNotExist</span></tt> 异常。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">from</span> <span class="nn">django.core.exceptions</span> <span class="k">import</span> <span class="n">ObjectDoesNotExist</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
<span class="k">except</span> <span class="n">ObjectDoesNotExist</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&quot;Either the entry or blog doesn&#39;t exist.&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="s-create-kwargs">
<span id="create-kwargs"></span><h4><tt class="docutils literal"><span class="pre">create(**kwargs)</span></tt><a class="headerlink" href="index.html#create-kwargs" title="Permalink to this headline">¶</a></h4>
<p>创建对象并同时保存对象的快捷方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">&quot;Bruce&quot;</span><span class="p">,</span> <span class="n">last_name</span><span class="o">=</span><span class="s">&quot;Springsteen&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>和</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">&quot;Bruce&quot;</span><span class="p">,</span> <span class="n">last_name</span><span class="o">=</span><span class="s">&quot;Springsteen&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">force_insert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>是相同的。</p>
<p><a class="reference external" href="../instances/index.html#ref-models-force-insert"><em>force_insert</em></a> 参数在别处有详细介绍，它表示把当前 model 当成一个新对象来创建。一般情况下，你不必担心这一点，但是如果你的 model 的主键是你手动指定的，而且它的值已经在数据库中存在，那么调用 <tt class="docutils literal"><span class="pre">create()</span></tt> 就会失败，并抛出 <tt class="docutils literal"><span class="pre">IntegrityError</span></tt>。这是因为主键值必须是唯一的。所以当你手动指定主键时，记得要做好处理异常的准备。</p>
</div>
<div class="section" id="s-get-or-create-kwargs">
<span id="get-or-create-kwargs"></span><h4><tt class="docutils literal"><span class="pre">get_or_create(**kwargs)</span></tt><a class="headerlink" href="index.html#get-or-create-kwargs" title="Permalink to this headline">¶</a></h4>
<p>这是一个方便实际应用的方法，它根据所给的筛选条件查询对象，如果对象不存在就创建一个新对象。</p>
<p>它返回的是一个 <tt class="docutils literal"><span class="pre">(object,</span> <span class="pre">created)</span></tt> 元组，其中的 <tt class="docutils literal"><span class="pre">object</span></tt> 是所读取或是创建的对象，而 <tt class="docutils literal"><span class="pre">created</span></tt> 则是一个布尔值，它表示前面提到的 <b>object</b> 是否是新创建的。</p>
<p>这意味着它可以有效地减少代码，并且对编写数据导入脚本非常有用。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">&#39;John&#39;</span><span class="p">,</span> <span class="n">last_name</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
<span class="k">except</span> <span class="n">Person</span><span class="o">.</span><span class="n">DoesNotExist</span><span class="p">:</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">&#39;John&#39;</span><span class="p">,</span> <span class="n">last_name</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">,</span> <span class="n">birthday</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mf">1940</span><span class="p">,</span> <span class="mf">10</span><span class="p">,</span> <span class="mf">9</span><span class="p">))</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>上面的代码会随着 model 中字段数量的激增而变得愈发庸肿。接下来用 <tt class="docutils literal"><span class="pre">get_or_create()</span></tt> 重写：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span><span class="p">,</span> <span class="n">created</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">&#39;John&#39;</span><span class="p">,</span> <span class="n">last_name</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">,</span>
                  <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;birthday&#39;</span><span class="p">:</span> <span class="n">date</span><span class="p">(</span><span class="mf">1940</span><span class="p">,</span> <span class="mf">10</span><span class="p">,</span> <span class="mf">9</span><span class="p">)})</span>
</pre></div>
</div>
<p>在这里要注意 <tt class="docutils literal"><span class="pre">defaults</span></tt> 是一个字典，它仅适用于创建对象时为字段赋值，而并不适用于查找已存在的对象。 <tt class="docutils literal"><span class="pre">get_or_create()</span></tt> 所接收的关键字参数都会在调用 <tt class="docutils literal"><span class="pre">get()</span></tt> 时被使用，有一个参数例外，就是 <tt class="docutils literal"><span class="pre">defaults</span></tt>。在使用<tt class="docutils literal"><span class="pre">get_or_create()</span></tt> 时如果找到了对象，就会返回这个对象和 <tt class="xref docutils literal"><span class="pre">False</span></tt>。如果没有找到，就会实例化一个新对象，并将其保存；同时返回这个新对象和 <tt class="xref docutils literal"><span class="pre">True</span></tt>。创建新对象的步骤大致如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">defaults</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;defaults&#39;</span><span class="p">,</span> <span class="p">{})</span>
<span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s">&#39;__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">])</span>
<span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span>
<span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
<span class="n">obj</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>用自然语言描述：从非 <tt class="docutils literal"><span class="pre">'defaults'</span></tt> 关键字参数中排除含有双下划线的参数（因为双下划线表示非精确查询），然后再添加 <tt class="docutils literal"><span class="pre">defaults</span></tt> 字典的内容，如果键名与已有的关键字参数重复，就以 <tt class="docutils literal"><span class="pre">defaults</span></tt> 中的内容为准, 然后将整理后的关键字参数传递给 model 类。当然，这只是算法的简化描述，实际上对很多细节没有提及，比如对异常和边界条件的处理。如果你对此感兴趣，不妨看一下原代码。</p>
<p>如果你的 model 恰巧有一个字段，名称正是 <tt class="docutils literal"><span class="pre">defaults</span></tt>，而且你想在 <tt class="docutils literal"><span class="pre">get_or_create()</span></tt> 中用它做为精确查询的条件, 就得使用 <tt class="docutils literal"><span class="pre">'defaults__exact'</span></tt> (之前提过 <tt class="docutils literal"><span class="pre">defaults</span></tt> 只能在创建时对对象赋值，而不能进行查询)，象下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Foo</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span><span class="n">defaults__exact</span><span class="o">=</span><span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;defaults&#39;</span><span class="p">:</span> <span class="s">&#39;baz&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>如果你手动指定了主键，那么使用 <tt class="docutils literal"><span class="pre">get_or_create()</span></tt> 方法时也会象 <tt class="docutils literal"><span class="pre">create()</span></tt> 一样，抛出类似的异常。当你手动指定了主键，若主键值已经在数据库中存在，就会抛出一个 <tt class="docutils literal"><span class="pre">IntegrityError</span></tt> 异常。</p>
<p>最后提一下在 Django 视图(views)中使用 <tt class="docutils literal"><span class="pre">get_or_create()</span></tt> 时要注意的一点。如上所说，对于在脚本中分析数据和添加新数据而言，<tt class="docutils literal"><span class="pre">get_or_create()</span></tt> 是非常有用的。但是如果你是在视图中使用 <tt class="docutils literal"><span class="pre">get_or_create()</span></tt> ，那么就要格外留意，要确认是在 <tt class="docutils literal"><span class="pre">POST</span></tt> 请求中使用，除非你有很必要和很充分的理由才不这么做。而在 <tt class="docutils literal"><span class="pre">GET</span></tt> 请求中使用的话，不会对数据产生任何作用。而使用 <tt class="docutils literal"><span class="pre">POST</span></tt> 的话，每个发往页面的请求都会对数据有一定的副作用。要了解更多，请查看 HTTP 规范中的 <a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1">安全方法(Safe methods)</a>。</p>
</div>
<div class="section" id="s-count">
<span id="count"></span><h4><tt class="docutils literal"><span class="pre">count()</span></tt><a class="headerlink" href="index.html#count" title="Permalink to this headline">¶</a></h4>
<p>返回数据库中匹配查询(<tt class="docutils literal"><span class="pre">QuerySet</span></tt>)的对象数量。 <tt class="docutils literal"><span class="pre">count()</span></tt> 不会抛出任何异常。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Returns the total number of entries in the database.</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

<span class="c"># Returns the number of entries whose headline contains &#39;Lennon&#39;</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">count()</span></tt> 会在后端执行 <tt class="docutils literal"><span class="pre">SELECT</span> <span class="pre">COUNT(*)</span></tt> 操作，所以你应该尽量使用 <tt class="docutils literal"><span class="pre">count()</span></tt> 而不是对返回的查询结果使用 <tt class="docutils literal"><span class="pre">len()</span></tt> 。</p>
<p>根据你所使用的数据库(例如 PostgreSQL 和 MySQL)，<tt class="docutils literal"><span class="pre">count()</span></tt> 可能会返回长整型，而不是普通的 Python 整数。这确实是一个很古怪的举措，没有什么实际意义。</p>
</div>
<div class="section" id="s-in-bulk-id-list">
<span id="in-bulk-id-list"></span><h4><tt class="docutils literal"><span class="pre">in_bulk(id_list)</span></tt><a class="headerlink" href="index.html#in-bulk-id-list" title="Permalink to this headline">¶</a></h4>
<p>接收一个主键值列表，然后根据每个主键值所其对应的对象，返回一个主键值与对象的映射字典。</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">in_bulk</span><span class="p">([</span><span class="mf">1</span><span class="p">])</span>
<span class="go">{1: &lt;Blog: Beatles Blog&gt;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">in_bulk</span><span class="p">([</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">])</span>
<span class="go">{1: &lt;Blog: Beatles Blog&gt;, 2: &lt;Blog: Cheddar Talk&gt;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">in_bulk</span><span class="p">([])</span>
<span class="go">{}</span>
</pre></div>
</div>
<p>如果你给 <tt class="docutils literal"><span class="pre">in_bulk()</span></tt> 传递的是一个空列表明，得到就是一个空字典。</p>
</div>
<div class="section" id="s-iterator">
<span id="iterator"></span><h4><tt class="docutils literal"><span class="pre">iterator()</span></tt><a class="headerlink" href="index.html#iterator" title="Permalink to this headline">¶</a></h4>
<p>运行查询(<tt class="docutils literal"><span class="pre">QuerySet</span></tt>)，然后根据结果返回一个 <a class="reference external" href="http://www.python.org/dev/peps/pep-0234/">迭代器(iterator</a>。 做为比较，使用 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 时，从数据库中读取所有记录后，一次性将所有记录实例化为对应的对象；而 <tt class="docutils literal"><span class="pre">iterator()</span></tt> 则是读取记录后，是分多次对数据实例化，用到哪个对象才实例化哪个对象。相对于一次性返回很多对象的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>，使用迭代器不仅效率更高，而且更节省内存。</p>
<p>要注意的是，如果将 <tt class="docutils literal"><span class="pre">iterator()</span></tt> 作用于 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>，那就意味着会再一次运行查询，就是说会运行两次查询。</p>
</div>
<div class="section" id="s-latest-field-name-none">
<span id="latest-field-name-none"></span><h4><tt class="docutils literal"><span class="pre">latest(field_name=None)</span></tt><a class="headerlink" href="index.html#latest-field-name-none" title="Permalink to this headline">¶</a></h4>
<p>根据时间字段 <tt class="docutils literal"><span class="pre">field_name</span></tt> 得到最新的对象。</p>
<p>下面这个例子根据 <tt class="docutils literal"><span class="pre">pub_date</span></tt> 字段得到数据表中最新的 <tt class="docutils literal"><span class="pre">Entry</span></tt> 对象：
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">latest</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你在 model 中 <tt class="docutils literal"><span class="pre">Meta</span></tt> 定义了 <tt class="docutils literal"><span class="pre">get_latest_by</span></tt> 项, 那么你可以略去 <tt class="docutils literal"><span class="pre">field_name</span></tt> 参数。Django 会将 <tt class="docutils literal"><span class="pre">get_latest_by</span></tt> 做为默认设置。</p>
<p>和 <tt class="docutils literal"><span class="pre">get()</span></tt>, <tt class="docutils literal"><span class="pre">latest()</span></tt> 一样，如果根据所给条件没有找到匹配的对象，就会抛出 <tt class="docutils literal"><span class="pre">DoesNotExist</span></tt> 异常。</p>
<p>注意 <tt class="docutils literal"><span class="pre">latest()</span></tt> 是纯粹为了易用易读而存在的方法。</p>
</div>
<div class="section" id="s-aggregate-args-kwargs">
<span id="aggregate-args-kwargs"></span><h4><tt class="docutils literal"><span class="pre">aggregate(*args,</span> <span class="pre">**kwargs)</span></tt><a class="headerlink" href="index.html#aggregate-args-kwargs" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">这部分是在 Django 1.1 中新增的：</span> <a class="reference external" href="../../../releases/1.1/index.html#releases-1-1"><em>请查看版本文档</em></a></div>
<p>通过对 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 进行计算，返回一个聚合值的字典。 <tt class="docutils literal"><span class="pre">aggregate()</span></tt> 中每个参数都指定一个包含在字典中的返回值。</p>
<p>在下面的 <a class="reference internal" href="index.html#id8">聚合函式(Aggregation Functions)</a> 中有对聚合函式的详细描述。</p>
<p>聚合使用关键字参数做为注解的名称。每个参数都有一个为其订做的名称，这个名称取决于聚合函式的函数名和聚合字段的名称。</p>
<p>例如，你正在处理博文，你想知道博客中一共有多少篇博文：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">))</span>
<span class="go">{&#39;entry__count&#39;: 16}</span>
</pre></div>
</div>
<p>通过在 <b>aggregate</b> 指定关键字参数，你可以控制返回的聚合名称：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">number_of_entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">))</span>
<span class="go">{&#39;number_of_entries&#39;: 16}</span>
</pre></div>
</div>
<p>要更深入的了解 <b>aggregation</b>，请查看 <a class="reference external" href="../../../topics/db/aggregation/index.html#topics-db-aggregation"><em>聚合指南(the topic guide on Aggregation)</em></a>.</p>
</div>
<div class="section" id="s-exists">
<span id="s-field-lookups"></span><span id="exists"></span><span id="field-lookups"></span><h4><tt class="docutils literal"><span class="pre">exists()</span></tt><a class="headerlink" href="index.html#exists" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">这是在 Django 开发版中新增的。</span> </div>
<p>如果 <a title="django.db.models.QuerySet" class="reference internal" href="index.html#django.db.models.QuerySet"><tt class="xref docutils literal"><span class="pre">QuerySet</span></tt></a> 包含有数据，就返回 <tt class="xref docutils literal"><span class="pre">True</span></tt> 否则就返回 <tt class="xref docutils literal"><span class="pre">False</span></tt>。这可能是最快最简单的查询方法了，但它的确会运行查询。某种程度上这意味着使用 <tt class="xref docutils literal"><span class="pre">QuerySet.exists()</span></tt> 比 <tt class="docutils literal"><span class="pre">bool(some_query_set)</span></tt> 更快。</p>
</div>
</div>
<div class="section" id="s-id7">
<span id="id7"></span><h3>字段筛选条件(Field lookups)<a class="headerlink" href="index.html#id7" title="Permalink to this headline">¶</a></h3>
<p>字段筛选条件决定了你如何构造 SQL 语句中的 <tt class="docutils literal"><span class="pre">WHERE</span></tt> 从句。它们被指定为 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 中 <tt class="docutils literal"><span class="pre">filter()</span></tt>，<tt class="docutils literal"><span class="pre">exclude()</span></tt> 和 <tt class="docutils literal"><span class="pre">get()</span></tt> 方法的关键字参数。</p>
<p>要了解这部分内容，可以查看 <a class="reference external" href="../../../topics/db/queries/index.html#field-lookups-intro"><em>字段查找条件(Field lookups)</em></a> 一节。</p>
<div class="section" id="s-exact">
<span id="exact"></span><h4>exact<a class="headerlink" href="index.html#exact" title="Permalink to this headline">¶</a></h4>
<p>精确匹配。如果指定的值是 <tt class="xref docutils literal"><span class="pre">None</span></tt>，就会翻译成 SQL 中的 <tt class="docutils literal"><span class="pre">NULL</span></tt> (详情请查看 <a class="reference internal" href="index.html#isnull">isnull</a> )。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mf">14</span><span class="p">)</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>等价的 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE id = 14;
SELECT ... WHERE id IS NULL;</pre>
</div>
<div class="versionchanged">
<span class="title">在 Django 1.0 有所改动：</span>  <tt class="docutils literal"><span class="pre">id__exact=None</span></tt> 的语义在 Django 1.0 中已经有所改变。之前，它可以在 SQL 中翻译为 <tt class="docutils literal"><span class="pre">WHERE</span> <span class="pre">id</span> <span class="pre">=</span> <span class="pre">NULL</span></tt>，就是不匹配任何数据。但现在它的作用却和 <tt class="docutils literal"><span class="pre">id__isnull=True</span></tt> 一样。</div>
<div class="admonition-mysql-comparisons admonition ">
<p class="first admonition-title">MySQL 提示</p>
<p class="last">在 MySQL 中，数据表的 <b>&quot;collation&quot;</b> 设置决定了 <tt class="docutils literal"><span class="pre">exact</span></tt> 比较是不是大小写敏感的。这是一个数据库设置，而<b>不是</b>一个 Django 设置。所以更改 MySQL 数据库的设置就能决定是否对大小写敏感，但是具体要不要这么做，仍需要根据实际情况进行权衡考虑。关这方面细节，请查看 <a class="reference external" href="../../databases/index.html#ref-databases"><em>数据库(databases)</em></a> 文档中 <a class="reference external" href="../../databases/index.html#mysql-collation"><em>collation section</em></a> 一节。</p>
</div>
</div>
<div class="section" id="s-iexact">
<span id="iexact"></span><h4>iexact<a class="headerlink" href="index.html#iexact" title="Permalink to this headline">¶</a></h4>
<p>忽略大小写的匹配。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name__iexact</span><span class="o">=</span><span class="s">&#39;beatles blog&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于如下 SQL ：</p>
<div class="highlight-python"><pre>SELECT ... WHERE name ILIKE 'beatles blog';</pre>
</div>
<p>要注意它能匹配 <tt class="docutils literal"><span class="pre">'Beatles</span> <span class="pre">Blog'</span></tt>, <tt class="docutils literal"><span class="pre">'beatles</span> <span class="pre">blog'</span></tt>, <tt class="docutils literal"><span class="pre">'BeAtLes</span>
<span class="pre">BLoG'</span></tt>，等等。</p>
<div class="admonition-sqlite-users admonition ">
<p class="first admonition-title">SQLite 用户要注意</p>
<p class="last">在使用 SQLite 作为数据库，并且应用 Unicode (non-ASCII) 字符串时，请先查看 <a class="reference external" href="../../databases/index.html#sqlite-string-matching"><em>database note</em></a> 中关于字符串比对那一节内容。SQLite 对 Unicode 字符串，无法做忽略大小写的匹配。</p>
</div>
</div>
<div class="section" id="s-contains">
<span id="contains"></span><h4>contains<a class="headerlink" href="index.html#contains" title="Permalink to this headline">¶</a></h4>
<p>大小写敏感的包含匹配。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于 SQL ：</p>
<div class="highlight-python"><pre>SELECT ... WHERE headline LIKE '%Lennon%';</pre>
</div>
<p>要注意，上述语句将匹配大标题 <tt class="docutils literal"><span class="pre">'Today</span> <span class="pre">Lennon</span> <span class="pre">honored'</span></tt> ，但不能匹配 <tt class="docutils literal"><span class="pre">'today</span> <span class="pre">lennon</span> <span class="pre">honored'</span></tt>。</p>
<p>SQLite 不支持大小写敏感的 <tt class="docutils literal"><span class="pre">LIKE</span></tt> 语句；所以对 SQLite 使用 <tt class="docutils literal"><span class="pre">contains</span></tt> 时就和使用 <tt class="docutils literal"><span class="pre">icontains</span></tt> 一样。</p>
</div>
<div class="section" id="s-icontains">
<span id="icontains"></span><h4>icontains<a class="headerlink" href="index.html#icontains" title="Permalink to this headline">¶</a></h4>
<p>忽略大小写的包含匹配。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__icontains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE headline ILIKE '%Lennon%';</pre>
</div>
<div class="admonition-sqlite-users admonition ">
<p class="first admonition-title">SQLite 用户请注意</p>
<p class="last">使用 SQLite 数据库并应用 Unicode (non-ASCII) 字符串时，请先查看 <a class="reference external" href="../../databases/index.html#sqlite-string-matching"><em>database note</em></a> 文档中关于字符串比对那一节内容。</p>
</div>
</div>
<div class="section" id="s-in">
<span id="in"></span><h4>in<a class="headerlink" href="index.html#in" title="Permalink to this headline">¶</a></h4>
<p>是否在一个给定的列表中。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">id__in</span><span class="o">=</span><span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="mf">4</span><span class="p">])</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE id IN (1, 3, 4);</pre>
</div>
<p>你也可以把查询(queryset)结果当做动态的列表，从而代替固定的列表：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inner_qs</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">&#39;Cheddar&#39;</span><span class="p">)</span>
<span class="n">entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__in</span><span class="o">=</span><span class="n">inner_qs</span><span class="p">)</span>
</pre></div>
</div>
<p>做动态列表的 queryset 运行时就会被做为一个子查询：</p>
<div class="highlight-python"><pre>SELECT ... WHERE blog.id IN (SELECT id FROM ... WHERE NAME LIKE '%Cheddar%')</pre>
</div>
<p>上面的代码也可以这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inner_q</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">&#39;Cheddar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;pk&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">query</span>
<span class="n">entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__in</span><span class="o">=</span><span class="n">inner_q</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<span class="title">在 Django 1.1 中已有发生改变：</span> 在 Django 1.0 中，只有最后一例代码是可用的。</div>
<p>Django 1.0 这种代码形式并不太自然，稍稍有点难读，由于它访问了内部的 <tt class="docutils literal"><span class="pre">query</span></tt> 属性，并且要用到 <tt class="docutils literal"><span class="pre">ValuesQuerySet</span></tt>。如果你的代码不需要兼容 Django 1.0，那么使用第一种形式，直接传递一个 queryset 就好。</p>
<p>如果你传递了一个 <tt class="docutils literal"><span class="pre">ValuesQuerySet</span></tt> 或 <tt class="docutils literal"><span class="pre">ValuesListQuerySet</span></tt> (它们是调用查询集上 <tt class="docutils literal"><span class="pre">values()</span></tt> 和 <tt class="docutils literal"><span class="pre">values_list()</span></tt> 方法的返回结果) 做为 <tt class="docutils literal"><span class="pre">__in</span></tt> 条件的值，那么你要确认只匹配返回结果中的一个字段。例如，下面的代码能正常的工作(对博客名称进行过滤)：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inner_qs</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">&#39;Ch&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)</span>
<span class="n">entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__name__in</span><span class="o">=</span><span class="n">inner_qs</span><span class="p">)</span>
</pre></div>
</div>
<p>下面的代码却会抛出异常，原因是内部的查询会尝试匹配两个字段值，但只有一个是有用的：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Bad code! Will raise a TypeError.</span>
<span class="n">inner_qs</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">&#39;Ch&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;id&#39;</span><span class="p">)</span>
<span class="n">entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__name__in</span><span class="o">=</span><span class="n">inner_qs</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last"> <tt class="docutils literal"><span class="pre">query</span></tt> 属性本是一个不公开的内部属性，虽然他在上面的代码中工作得很好，但是它的API很可能会在不同的 Django 版本中经常变动。</p>
</div>
<div class="admonition-performance-considerations admonition ">
<p class="first admonition-title">性能考虑</p>
<p>要谨慎使用嵌套查询，并且要对你所采用的数据库性能有所了解(如果不了解，就去做一下性能测试)。有些数据库，比如著名的MySQL，就不能很好地优化嵌套查询。所以在上面的案例中，先在第一个查询中提取值列表，然后再将其传递给第二个查询，会对性能有较高的提升。说白了，就是用两个高效的查询替换掉一个低效的查询：</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">values</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">name__contains</span><span class="o">=</span><span class="s">&#39;Cheddar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;pk&#39;</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__in</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-gt">
<span id="gt"></span><h4>gt<a class="headerlink" href="index.html#gt" title="Permalink to this headline">¶</a></h4>
<p>大于。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">id__gt</span><span class="o">=</span><span class="mf">4</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE id &gt; 4;</pre>
</div>
</div>
<div class="section" id="s-gte">
<span id="gte"></span><h4>gte<a class="headerlink" href="index.html#gte" title="Permalink to this headline">¶</a></h4>
<p>大于等于。</p>
</div>
<div class="section" id="s-lt">
<span id="lt"></span><h4>lt<a class="headerlink" href="index.html#lt" title="Permalink to this headline">¶</a></h4>
<p>小于。</p>
</div>
<div class="section" id="s-lte">
<span id="lte"></span><h4>lte<a class="headerlink" href="index.html#lte" title="Permalink to this headline">¶</a></h4>
<p>小于等于。</p>
</div>
<div class="section" id="s-startswith">
<span id="startswith"></span><h4>startswith<a class="headerlink" href="index.html#startswith" title="Permalink to this headline">¶</a></h4>
<p>大小写敏感的以....开头。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s">&#39;Will&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE headline LIKE 'Will%';</pre>
</div>
<p>SQLite 不支持大小写敏感的 <tt class="docutils literal"><span class="pre">LIKE</span></tt> 语句；所以在 SQLite 中使用 <tt class="docutils literal"><span class="pre">startswith</span></tt> 就和使用 <tt class="docutils literal"><span class="pre">istartswith</span></tt> 一样。</p>
</div>
<div class="section" id="s-istartswith">
<span id="istartswith"></span><h4>istartswith<a class="headerlink" href="index.html#istartswith" title="Permalink to this headline">¶</a></h4>
<p>忽略大小写的以....开头。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__istartswith</span><span class="o">=</span><span class="s">&#39;will&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE headline ILIKE 'Will%';</pre>
</div>
<div class="admonition-sqlite-users admonition ">
<p class="first admonition-title">SQLite 用户请注意</p>
<p class="last">在使用 SQLite 数据库并应用 Unicode (non-ASCII) 字符串时，请先查看 <a class="reference external" href="../../databases/index.html#sqlite-string-matching"><em>database note</em></a> 文档中有关字符串对比那一切的内容。</p>
</div>
</div>
<div class="section" id="s-endswith">
<span id="endswith"></span><h4>endswith<a class="headerlink" href="index.html#endswith" title="Permalink to this headline">¶</a></h4>
<p>大小写敏感的以....结尾。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__endswith</span><span class="o">=</span><span class="s">&#39;cats&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE headline LIKE '%cats';</pre>
</div>
<p>SQLite 不支持大小写敏感的 <tt class="docutils literal"><span class="pre">LIKE</span></tt> 语句；所以在 SQLite 中使用 <tt class="docutils literal"><span class="pre">endswith</span></tt> 就象使用 <tt class="docutils literal"><span class="pre">iendswith</span></tt> 一样。</p>
</div>
<div class="section" id="s-iendswith">
<span id="iendswith"></span><h4>iendswith<a class="headerlink" href="index.html#iendswith" title="Permalink to this headline">¶</a></h4>
<p>忽略大小写的以....结尾。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__iendswith</span><span class="o">=</span><span class="s">&#39;will&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE headline ILIKE '%will'</pre>
</div>
<div class="admonition-sqlite-users admonition ">
<p class="first admonition-title">SQLite users</p>
<p class="last">在使用 SQLite 数据库和应用 Unicode (non-ASCII) 字符串时，请先查看 <a class="reference external" href="../../databases/index.html#sqlite-string-matching"><em>database note</em></a> 文档中有关字符串对比那一节内容。</p>
</div>
</div>
<div class="section" id="s-range">
<span id="range"></span><h4>range<a class="headerlink" href="index.html#range" title="Permalink to this headline">¶</a></h4>
<p>包含的范围。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">start_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mf">2005</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">1</span><span class="p">)</span>
<span class="n">end_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mf">2005</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="mf">31</span><span class="p">)</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__range</span><span class="o">=</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">))</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE pub_date BETWEEN '2005-01-01' and '2005-03-31';</pre>
</div>
<p>你可以把 <tt class="docutils literal"><span class="pre">range</span></tt> 当成 SQL 中的 <tt class="docutils literal"><span class="pre">BETWEEN</span></tt> 来用，比如日期，数字，甚至是字符。</p>
</div>
<div class="section" id="s-year">
<span id="year"></span><h4>year<a class="headerlink" href="index.html#year" title="Permalink to this headline">¶</a></h4>
<p>对日期／时间字段精确匹配年分，年分用四位数字表示。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mf">2005</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE EXTRACT('year' FROM pub_date) = '2005';</pre>
</div>
<p>(不同的数据库引擎中，翻译得到的 SQL 也不尽相同。)</p>
</div>
<div class="section" id="s-month">
<span id="month"></span><h4>month<a class="headerlink" href="index.html#month" title="Permalink to this headline">¶</a></h4>
<p>对日期／时间字段精确匹配月分，用整数表示月分，比如 1 表示一月，12 表示十二月。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__month</span><span class="o">=</span><span class="mf">12</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE EXTRACT('month' FROM pub_date) = '12';</pre>
</div>
<p>(不同的数据库引擎中，翻译得到的 SQL 也不尽相同。)</p>
</div>
<div class="section" id="s-day">
<span id="day"></span><h4>day<a class="headerlink" href="index.html#day" title="Permalink to this headline">¶</a></h4>
<p>对日期／时间字段精确匹配日期。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__day</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE EXTRACT('day' FROM pub_date) = '3';</pre>
</div>
<p>(不同的数据库引擎中，翻译得到的 SQL 也不尽相同。)</p>
<p>要注意的是，这个匹配只会得到所有 <b>pub_date</b> 字段内容是表示 <b>某月的第三天</b> 的记录，如一月三号，六月三号。而十月二十三号就不在此列。</p>
</div>
<div class="section" id="s-week-day">
<span id="week-day"></span><h4>week_day<a class="headerlink" href="index.html#week-day" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">这部分是在 Django 1.1 中新增的：</span> <a class="reference external" href="../../../releases/1.1/index.html#releases-1-1"><em>请查看版本文档</em></a></div>
<p>对日期／时间字段匹配星期几</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__week_day</span><span class="o">=</span><span class="mf">2</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE EXTRACT('dow' FROM pub_date) = '2';</pre>
</div>
<p>(不同的数据库引擎中，翻译得到的 SQL 也不尽相同。)</p>
<p>要注意的是，这段代码将得到 pub_date 字段是星期一的所有记录 (西方习惯于将星期一看做一周的第二天)，与它的年月信息无关。星期以星期天做为第一天，以星期六做为最后一天。</p>
</div>
<div class="section" id="s-isnull">
<span id="isnull"></span><h4>isnull<a class="headerlink" href="index.html#isnull" title="Permalink to this headline">¶</a></h4>
<p> 根据 SQL 查询是空 <tt class="docutils literal"><span class="pre">IS</span> <span class="pre">NULL</span></tt> 还是非空 <tt class="docutils literal"><span class="pre">IS</span> <span class="pre">NOT</span> <span class="pre">NULL</span></tt>，返回相应的 <tt class="xref docutils literal"><span class="pre">True</span></tt> 或 <tt class="xref docutils literal"><span class="pre">False</span></tt>。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__isnull</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE pub_date IS NULL;</pre>
</div>
</div>
<div class="section" id="s-search">
<span id="search"></span><h4>search<a class="headerlink" href="index.html#search" title="Permalink to this headline">¶</a></h4>
<p>利用全文索引做全文搜索。它与 <tt class="docutils literal"><span class="pre">contains</span></tt> 相似，但使用全文索引做搜索会更快一些。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__search</span><span class="o">=</span><span class="s">&quot;+Django -jazz Python&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于：</p>
<div class="highlight-python"><pre>SELECT ... WHERE MATCH(tablename, headline) AGAINST (+Django -jazz Python IN BOOLEAN MODE);</pre>
</div>
<p>要注意这个方法仅适用于 MySQL ，并且要求设置全文索引。默认情况下 Django 使用 BOOLEAN MODE 模式。详见 <a class="reference external" href="http://dev.mysql.com/doc/refman/5.1/en/fulltext-boolean.html">Please check MySQL documentation for additional details.</a></p>
</div>
<div class="section" id="s-regex">
<span id="regex"></span><h4>regex<a class="headerlink" href="index.html#regex" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">这部分是在 Django 1.0 中新增的：</span> <a class="reference external" href="../../../releases/1.0/index.html#releases-1-0"><em>请查看版本文档</em></a></div>
<p>大小写敏感的正则表达式匹配。</p>
<p>它要求数据库支持正则表达式语法，而 SQLite 却没有内建正则表达式支持，因此 SQLite 的这个特性是由一个名为 REGEXP 的 Python 方法实现的，所以要用到 Python 的正则库 <tt class="docutils literal"><span class="pre">re</span></tt>.</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">title__regex</span><span class="o">=</span><span class="s">r&#39;^(An?|The) +&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于 SQL：</p>
<div class="highlight-python"><pre>SELECT ... WHERE title REGEXP BINARY '^(An?|The) +'; -- MySQL

SELECT ... WHERE REGEXP_LIKE(title, '^(an?|the) +', 'c'); -- Oracle

SELECT ... WHERE title ~ '^(An?|The) +'; -- PostgreSQL

SELECT ... WHERE title REGEXP '^(An?|The) +'; -- SQLite</pre>
</div>
<p>建议使用原生字符串 (例如，用 <tt class="docutils literal"><span class="pre">r'foo'</span></tt> 替换 <tt class="docutils literal"><span class="pre">'foo'</span></tt>) 做为正则表达式。</p>
</div>
<div class="section" id="s-iregex">
<span id="iregex"></span><h4>iregex<a class="headerlink" href="index.html#iregex" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">这部分是在 Django 1.0 中新增的：</span> <a class="reference external" href="../../../releases/1.0/index.html#releases-1-0"><em>请查看版本文档</em></a></div>
<p>忽略大小写的正则表达式匹配。</p>
<p>匹配：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">title__iregex</span><span class="o">=</span><span class="s">r&#39;^(an?|the) +&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于SQL ：</p>
<div class="highlight-python"><pre>SELECT ... WHERE title REGEXP '^(an?|the) +'; -- MySQL

SELECT ... WHERE REGEXP_LIKE(title, '^(an?|the) +', 'i'); -- Oracle

SELECT ... WHERE title ~* '^(an?|the) +'; -- PostgreSQL

SELECT ... WHERE title REGEXP '(?i)^(an?|the) +'; -- SQLite</pre>
</div>
</div>
</div>
<div class="section" id="s-id8">
<span id="s-aggregation-functions"></span><span id="id8"></span><span id="aggregation-functions"></span><h3>聚合函式(Aggregation Functions)<a class="headerlink" href="index.html#id8" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<span class="title">这部分是在 Django 1.1 中新增的：</span> <a class="reference external" href="../../../releases/1.1/index.html#releases-1-1"><em>请查看版本文档</em></a></div>
<p>Django 为继续自 <tt class="docutils literal"><span class="pre">django.db.models</span></tt> 的 module 中提供了一系列的聚合函式。要详细了解如何使用这些聚合函式，请查看 <a class="reference external" href="../../../topics/db/aggregation/index.html#topics-db-aggregation"><em>the topic guide on aggregation</em></a>。</p>
<div class="section" id="s-avg">
<span id="avg"></span><h4><tt class="docutils literal"><span class="pre">Avg</span></tt><a class="headerlink" href="index.html#avg" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="django.db.models.Avg">
<!--[django.db.models.Avg]-->class <tt class="descname">Avg</tt>(<em>field</em>)<a class="headerlink" href="index.html#django.db.models.Avg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>返回所给字段的平均值。</p>
<ul class="simple">
<li>默认别名：<tt class="docutils literal"><span class="pre">&lt;field&gt;__avg</span></tt></li>
<li>返回类型： float</li>
</ul>
</div>
<div class="section" id="s-id9">
<span id="id9"></span><h4><tt class="docutils literal"><span class="pre">Count</span></tt><a class="headerlink" href="index.html#id9" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="django.db.models.Count">
<!--[django.db.models.Count]-->class <tt class="descname">Count</tt>(<em>field</em>, <em>distinct=False</em>)<a class="headerlink" href="index.html#django.db.models.Count" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>根据所给的关联字段返回被关联 model 的数量。</p>
<ul class="simple">
<li>默认别名： <tt class="docutils literal"><span class="pre">&lt;field&gt;__count</span></tt></li>
<li>返回类型： integer</li>
</ul>
<p>它有一个可选参数：</p>
<dl class="attribute">
<dt id="django.db.models.distinct">
<!--[django.db.models.distinct]--><tt class="descname">distinct</tt><a class="headerlink" href="index.html#django.db.models.distinct" title="Permalink to this definition">¶</a></dt>
<dd>如果 <b>distinct=True</b>，那么只返回不重复的实例数量，相当于 SQL 中的 <tt class="docutils literal"><span class="pre">COUNT(DISTINCT</span> <span class="pre">field)</span></tt>。默认值是 <tt class="xref docutils literal"><span class="pre">False</span></tt>。</dd></dl>

</div>
<div class="section" id="s-max">
<span id="max"></span><h4><tt class="docutils literal"><span class="pre">Max</span></tt><a class="headerlink" href="index.html#max" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="django.db.models.Max">
<!--[django.db.models.Max]-->class <tt class="descname">Max</tt>(<em>field</em>)<a class="headerlink" href="index.html#django.db.models.Max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>返回所给字段的最大值。</p>
<ul class="simple">
<li>默认别名： <tt class="docutils literal"><span class="pre">&lt;field&gt;__max</span></tt></li>
<li>返回类型： 与所给字段值相同</li>
</ul>
</div>
<div class="section" id="s-min">
<span id="min"></span><h4><tt class="docutils literal"><span class="pre">Min</span></tt><a class="headerlink" href="index.html#min" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="django.db.models.Min">
<!--[django.db.models.Min]-->class <tt class="descname">Min</tt>(<em>field</em>)<a class="headerlink" href="index.html#django.db.models.Min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>返回所给字段的最小值。</p>
<ul class="simple">
<li>默认别名： <tt class="docutils literal"><span class="pre">&lt;field&gt;__min</span></tt></li>
<li>返回类型： 与所给字段相同</li>
</ul>
</div>
<div class="section" id="s-stddev">
<span id="stddev"></span><h4><tt class="docutils literal"><span class="pre">StdDev</span></tt><a class="headerlink" href="index.html#stddev" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="django.db.models.StdDev">
<!--[django.db.models.StdDev]-->class <tt class="descname">StdDev</tt>(<em>field</em>, <em>sample=False</em>)<a class="headerlink" href="index.html#django.db.models.StdDev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>返回所给字段值的标准差。</p>
<ul class="simple">
<li>默认别名： <tt class="docutils literal"><span class="pre">&lt;field&gt;__stddev</span></tt></li>
<li>返回类型： float</li>
</ul>
<p>它有一个可选参数：</p>
<dl class="attribute">
<dt id="django.db.models.sample">
<!--[django.db.models.sample]--><tt class="descname">sample</tt><a class="headerlink" href="index.html#django.db.models.sample" title="Permalink to this definition">¶</a></dt>
<dd>默认情况下， <tt class="docutils literal"><span class="pre">StdDev</span></tt> 返回一个总体偏差值，但是如果 <tt class="docutils literal"><span class="pre">sample=True</span></tt>，则返回一个样本偏差值。</dd></dl>

<div class="admonition-sqlite admonition ">
<p class="first admonition-title">SQLite</p>
<p class="last">SQLite 本身并不提供 <tt class="docutils literal"><span class="pre">StdDev</span></tt> 支持，可以使用 SQLite 的外置模块实现这个功能。详情请查看相应的 SQLite 文档，了解如何获得和安装扩展。</p>
</div>
</div>
<div class="section" id="s-sum">
<span id="sum"></span><h4><tt class="docutils literal"><span class="pre">Sum</span></tt><a class="headerlink" href="index.html#sum" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="django.db.models.Sum">
<!--[django.db.models.Sum]-->class <tt class="descname">Sum</tt>(<em>field</em>)<a class="headerlink" href="index.html#django.db.models.Sum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>计算所给字段值的总和</p>
<ul class="simple">
<li>默认别名： <tt class="docutils literal"><span class="pre">&lt;field&gt;__sum</span></tt></li>
<li>返回类型： 与所给字段相同</li>
</ul>
</div>
<div class="section" id="s-variance">
<span id="variance"></span><h4><tt class="docutils literal"><span class="pre">Variance</span></tt><a class="headerlink" href="index.html#variance" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="django.db.models.Variance">
<!--[django.db.models.Variance]-->class <tt class="descname">Variance</tt>(<em>field</em>, <em>sample=False</em>)<a class="headerlink" href="index.html#django.db.models.Variance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>返回所给字段值的标准方差。</p>
<ul class="simple">
<li>默认别名： <tt class="docutils literal"><span class="pre">&lt;field&gt;__variance</span></tt></li>
<li>返回类型： float</li>
</ul>
<p>它有一个可选参数：</p>
<dl class="attribute">
<dt>
<tt class="descname">sample</tt></dt>
<dd>默认情况下， <tt class="docutils literal"><span class="pre">Variance</span></tt> 返回的是总体方差；如果 <tt class="docutils literal"><span class="pre">sample=True</span></tt>，返回的则是样式方差。</dd></dl>

<div class="admonition-sqlite admonition ">
<p class="first admonition-title">SQLite</p>
<p class="last">SQLite 本身并不提供 <tt class="docutils literal"><span class="pre">Variance</span></tt> 支持，可以使用 SQLite 的外置模块实现这个功能。详情请查看相应的 SQLite 文档，了解如何获得和安装扩展。</p>
</div>
</div>
</div>
</div>
</div>



<div id="content-secondary">
  <h2 id="comments">Questions/Feedback</h2>
  <p>Having trouble? We'd like to help!</p>
  <ul>
    <li>
      Try the <a href="../../../faq/index.html">FAQ</a> — it's got answers to many common
      questions.
    </li>
    <li>
      Search for information in the <a
      href="http://groups.google.com/group/django-users/">archives of the
      django-users mailing list</a>, or <a
      href="http://groups.google.com/group/django-users/">post a question</a>.
    </li>
    <li>
      Ask a question in the <a href="irc://irc.freenode.net/">#django IRC
      channel</a>, or search the <a href="http://oebfare.com/logger/django/">IRC
      logs</a> to see if its been asked before.
    </li>
    <li>
      If you notice errors with this documentation, please <a
      href="http://code.djangoproject.com/simpleticket?component=Documentation">
      open a ticket</a> and let us know! Please only use the ticket tracker for
      criticisms and improvements on the docs. For tech support, use the
      resources above.
    </li>
  </ul>
</div>

		</div>
		<!-- END #content-main -->
		<div id="content-related" class="sidebar">
		
  
    <h2>Contents</h2>
    
      <ul>
<li><a class="reference external" href="index.html">QuerySet API reference</a><ul>
<li><a class="reference external" href="index.html#id1">When QuerySets are evaluated</a><ul>
<li><a class="reference external" href="index.html#id2">Pickling QuerySets</a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#id3">QuerySet API</a><ul>
<li><a class="reference external" href="index.html#queryset-methods-that-return-new-querysets">QuerySet methods that return new QuerySets</a><ul>
<li><a class="reference external" href="index.html#filter-kwargs"><tt class="docutils literal"><span class="pre">filter(**kwargs)</span></tt></a></li>
<li><a class="reference external" href="index.html#exclude-kwargs"><tt class="docutils literal"><span class="pre">exclude(**kwargs)</span></tt></a></li>
<li><a class="reference external" href="index.html#annotate-args-kwargs"><tt class="docutils literal"><span class="pre">annotate(*args,</span> <span class="pre">**kwargs)</span></tt></a></li>
<li><a class="reference external" href="index.html#order-by-fields"><tt class="docutils literal"><span class="pre">order_by(*fields)</span></tt></a></li>
<li><a class="reference external" href="index.html#reverse"><tt class="docutils literal"><span class="pre">reverse()</span></tt></a></li>
<li><a class="reference external" href="index.html#distinct"><tt class="docutils literal"><span class="pre">distinct()</span></tt></a></li>
<li><a class="reference external" href="index.html#values-fields"><tt class="docutils literal"><span class="pre">values(*fields)</span></tt></a></li>
<li><a class="reference external" href="index.html#values-list-fields"><tt class="docutils literal"><span class="pre">values_list(*fields)</span></tt></a></li>
<li><a class="reference external" href="index.html#dates-field-kind-order-asc"><tt class="docutils literal"><span class="pre">dates(field,</span> <span class="pre">kind,</span> <span class="pre">order='ASC')</span></tt></a></li>
<li><a class="reference external" href="index.html#none"><tt class="docutils literal"><span class="pre">none()</span></tt></a></li>
<li><a class="reference external" href="index.html#all"><tt class="docutils literal"><span class="pre">all()</span></tt></a></li>
<li><a class="reference external" href="index.html#id4"><tt class="docutils literal"><span class="pre">select_related()</span></tt></a></li>
<li><a class="reference external" href="index.html#extra-select-none-where-none-params-none-tables-none-order-by-none-select-params-none"><tt class="docutils literal"><span class="pre">extra(select=None,</span> <span class="pre">where=None,</span> <span class="pre">params=None,</span> <span class="pre">tables=None,</span> <span class="pre">order_by=None,</span> <span class="pre">select_params=None)</span></tt></a></li>
<li><a class="reference external" href="index.html#defer-fields"><tt class="docutils literal"><span class="pre">defer(*fields)</span></tt></a></li>
<li><a class="reference external" href="index.html#only-fields"><tt class="docutils literal"><span class="pre">only(*fields)</span></tt></a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#queryset-methods-that-do-not-return-querysets">QuerySet methods that do not return QuerySets</a><ul>
<li><a class="reference external" href="index.html#id5"><tt class="docutils literal"><span class="pre">get(**kwargs)</span></tt></a></li>
<li><a class="reference external" href="index.html#create-kwargs"><tt class="docutils literal"><span class="pre">create(**kwargs)</span></tt></a></li>
<li><a class="reference external" href="index.html#get-or-create-kwargs"><tt class="docutils literal"><span class="pre">get_or_create(**kwargs)</span></tt></a></li>
<li><a class="reference external" href="index.html#count"><tt class="docutils literal"><span class="pre">count()</span></tt></a></li>
<li><a class="reference external" href="index.html#in-bulk-id-list"><tt class="docutils literal"><span class="pre">in_bulk(id_list)</span></tt></a></li>
<li><a class="reference external" href="index.html#iterator"><tt class="docutils literal"><span class="pre">iterator()</span></tt></a></li>
<li><a class="reference external" href="index.html#latest-field-name-none"><tt class="docutils literal"><span class="pre">latest(field_name=None)</span></tt></a></li>
<li><a class="reference external" href="index.html#aggregate-args-kwargs"><tt class="docutils literal"><span class="pre">aggregate(*args,</span> <span class="pre">**kwargs)</span></tt></a></li>
<li><a class="reference external" href="index.html#exists"><tt class="docutils literal"><span class="pre">exists()</span></tt></a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#id7">Field lookups</a><ul>
<li><a class="reference external" href="index.html#exact">exact</a></li>
<li><a class="reference external" href="index.html#iexact">iexact</a></li>
<li><a class="reference external" href="index.html#contains">contains</a></li>
<li><a class="reference external" href="index.html#icontains">icontains</a></li>
<li><a class="reference external" href="index.html#in">in</a></li>
<li><a class="reference external" href="index.html#gt">gt</a></li>
<li><a class="reference external" href="index.html#gte">gte</a></li>
<li><a class="reference external" href="index.html#lt">lt</a></li>
<li><a class="reference external" href="index.html#lte">lte</a></li>
<li><a class="reference external" href="index.html#startswith">startswith</a></li>
<li><a class="reference external" href="index.html#istartswith">istartswith</a></li>
<li><a class="reference external" href="index.html#endswith">endswith</a></li>
<li><a class="reference external" href="index.html#iendswith">iendswith</a></li>
<li><a class="reference external" href="index.html#range">range</a></li>
<li><a class="reference external" href="index.html#year">year</a></li>
<li><a class="reference external" href="index.html#month">month</a></li>
<li><a class="reference external" href="index.html#day">day</a></li>
<li><a class="reference external" href="index.html#week-day">week_day</a></li>
<li><a class="reference external" href="index.html#isnull">isnull</a></li>
<li><a class="reference external" href="index.html#search">search</a></li>
<li><a class="reference external" href="index.html#regex">regex</a></li>
<li><a class="reference external" href="index.html#iregex">iregex</a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#id8">Aggregation Functions</a><ul>
<li><a class="reference external" href="index.html#avg"><tt class="docutils literal"><span class="pre">Avg</span></tt></a></li>
<li><a class="reference external" href="index.html#id9"><tt class="docutils literal"><span class="pre">Count</span></tt></a></li>
<li><a class="reference external" href="index.html#max"><tt class="docutils literal"><span class="pre">Max</span></tt></a></li>
<li><a class="reference external" href="index.html#min"><tt class="docutils literal"><span class="pre">Min</span></tt></a></li>
<li><a class="reference external" href="index.html#stddev"><tt class="docutils literal"><span class="pre">StdDev</span></tt></a></li>
<li><a class="reference external" href="index.html#sum"><tt class="docutils literal"><span class="pre">Sum</span></tt></a></li>
<li><a class="reference external" href="index.html#variance"><tt class="docutils literal"><span class="pre">Variance</span></tt></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    
  
  
  
    <h2>Search</h2>
    
    <form action="../../../search/index.html" id="search" class="search">
  <div>
    <input type="hidden" name="cx" value="009763561546736975936:e88ek0eurf4" />
    <input type="hidden" name="cof" value="FORID:11" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="hidden" name="hl" value="" />
    <input id="id_search_q" type="text" class="query" name="q" />
    <input type="submit" name="sa" class="submit" value="Search" />
    <ul>
<li><label for="id_search_as_q_0"><input checked="checked" type="radio" id="id_search_as_q_0" value="more:dev_docs" name="as_q" /> Latest</label></li>
<li><label for="id_search_as_q_1"><input type="radio" id="id_search_as_q_1" value="more:1.0_docs" name="as_q" /> 1.0</label></li>
<li><label for="id_search_as_q_2"><input type="radio" id="id_search_as_q_2" value="more:0.96_docs" name="as_q" /> 0.96</label></li>
<li><label for="id_search_as_q_3"><input type="radio" id="id_search_as_q_3" value="more:all_docs" name="as_q" /> All</label></li>
</ul>
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=search&amp;lang="></script>
  
  
  
    <h2>Browse</h2>
    <ul>
      
        
          <li>Prev: <a href="../instances/index.html">Model instance reference</a></li>
        
        
          <li>Next: <a href="../../request-response/index.html">Request and response objects</a></li>
        
        <li><a href="../../../contents/index.html">Table of contents</a></li>
        
          <li><a href="../../../genindex/index.html">General Index</a></li>
        
          <li><a href="../../../modindex/index.html">Global Module Index</a></li>
        
      
    </ul>
  
  
  
    <h2>You are here:</h2>
    <ul>
      
        <li>
          <a href="../../../index.html">Django dev documentation</a>
          
            <ul><li><a href="../../index.html">API Reference</a>
          
            <ul><li><a href="../index.html">Models</a>
          
          <ul><li>QuerySet API reference</li></ul>
          </li></ul></li></ul>
        </li>
      
    </ul>
  
  
  
    <h3>Last update:</h3>
    <div>November 19, 2009, 4 p.m. (<a href="http://www.timeanddate.com/worldclock/city.html?n=64">CDT</a>)</div>
  

		</div>
		<!-- END #content-related -->

		</div>
		<!-- END #content -->
		<div id="footer">
			<p>&copy; 2005-2009 <a href="http://www.djangoproject.com/foundation/">Django Software Foundation</a> unless otherwise noted. Django is a registered trademark of the Django Software Foundation. 
			Hosting graciously provided by <a href="http://mediatemple.net/">
			<img style="vertical-align: middle; position: relative; top: -1px;" src="http://media.djangoproject.com/img/site/mt.png" alt="media temple" /></a>
			</p>
		</div>
		<!-- END #footer -->
	</div>
	<!-- END #container -->
	</body>
</html>

